Унифицированные драйверы для работы с платами ЛА-XXX в операционной системе Windows 95/98/Me.
1. Введение.
Драйверы предназначены для написания программ управления функциональными возможностями плат АЦП в среде WINDOWS 95/98/Me, при этом пользователю необязательно знать тонкости программирования на уровне портов ввода - вывода. Драйверы представляют собой библиотеку функций управления, оформлены в виде DLL и поддерживают унифицированный интерфейс, который обеспечивает возможность их применения для различных сред программирования, при этом код написания программы не зависит от типа используемой платы.
Библиотека содержит функции, позволяющие осуществлять ввод - вывод аналоговой и цифровой информации в асинхронном режиме, вводить и выводить аналоговую информацию, как в одноканальном, так и в многоканальном режимах с произвольной синхронизацией ввода, вводить и выводить данные в программном режиме, в режиме генерации прерываний и по каналам DMA. Кроме того, программисту доступны функции низкоуровневого программирования. С их помощью можно программировать отдельные регистры ввода/вывода, а также различные функциональные устройства, такие как таймеры, синтезаторы частоты, подстроечные DAC и т.д.
2. Состав поставки.
2.1. Структура поставляемого программного обеспечения
Программное обеспечение, входящее в комплект поставки можно классифицировать следующим образом:
I.	По программной платформе, для которой предназначено то или иное программное обеспечение:
1.	ПО под MSDOS (или 100% совместимые операционные системы);
2.	ПО под MS Windows 3.X (ещё сохранилось, но уже практически не поддерживается);
3.	ПО под MS Windows 9X/Me.
II.	По функциональному назначению:
1.	Средства для разработчиков программного обеспечения, которые, в свою очередь, подразделяются следующим образом:
1.1.	Интерфейсы;
1.2.	Примеры программирования;
1.3.	Документация;
2.	Драйверы устройств;
3.	Готовые приложения;

В этом документе рассматриваются поставляемые средства для разработчиков программного обеспечения под MS Windows 9X/Me и драйверы устройств АЦП.

2.2. Структура каталогов, создаваемая в процессе установки поставляемого программного обеспечения, и размещение файлов
По умолчанию все файлы устанавливаются в каталог “C:\Program Files\Vt\”, кроме виртуального драйвера intdmaXXX.vxd (устанавливаются в системный каталог Windows; если Windows располагается в каталоге C:\Windows, то  это “C:\Windows\System\”  для Windows 9X/Me и “C:\Windows\System32\” для Windows NT/2K соответственно). Программа установки создаёт следующую структуру каталогов (внутри базового “..\Program Files\Vt\”):

Каталог	Файл	Описание
Dll	IntDmaXXX.dll	драйвер абстракции ввода-вывода, реализующий единый интерфейс программирования контроллеров прерываний и ПДП вне зависимости от аппаратной реализации и операционной системы
	LAUtilX.dll	библиотека организации непрерывного сбора данных для плат, работающих по DMA
	DSPUtil.dll	библиотека функций цифровой обработки сигналов
	ZoomerXXX.dll	библиотека функций отображения сигналов
Doc	..	Driver.doc	примерно то, что вы читаете в настоящее время
		LibraryRUS.doc	руководство по программированию плат в среде LabView
	ADCLab	ADCLab.htm	описание программы ADCLab
		*.gif и *.png	картинки, используемые в описании программы ADCLab
Drivers	LAXXX.dll	драйверы плат
	ADCDriver.ocx и ADCDriver.tlb	OCX-компонента, обёртка драйвера для приверженцев технологии OLE/ActiveX
Interfaces	..	ADC_Const.*	заголовочные файлы с константами, используемыми для работы с драйвером
		IADCDevice.*	заголовочный файл с прототипом класса интерфейса драйвера и структур данных для управления параметрами измерений
		IFactory.*	заголовочный файл с прототипом класса фабрики для получения интерфейса у загруженного в память драйвера или библиотеки
		DllClient.*	заголовочный файл класса для работы с поставляемыми библиотеками динамической компоновки (например, драйверами)
		IADCUtility.h и ADCUtility.pas	заголовочные файлы с прототипом класса из библиотеки ADCUtility.dll для организации непрерывного сбора данных по DMA
		UniDriver.*	заголовочные файлы библиотеки-обёртки интерфейса драйвера для не объектно-ориентированных сред программирования (или где трудно или невозможно использовать объекты (классы) в стиле C++)
		UniDriver4LV.h	заголовочный файл библиотеки-обёртки интерфейса драйвера  для LabView
		VT_Drivers.pas	константы, определяющие названия ключей системного реестра Windows, в которые записывается информация драйверами при регистрации
	REGKEY	VT_Drivers.ri	константы, определяющие названия ключей системного реестра Windows, в которые записывается информация драйверами при регистрации
		VT_Library.ri	константы, определяющие названия ключей системного реестра Windows, в которые записывается информация библиотеками при регистрации
Smaples	OCX	Исходные тексты OCX-компоненты
	UniDriver	Исходные тексты библиотеки-обёртки интерфейса драйвера
	остальные каталоги	промеры программирования для различных сред программирования и плат АЦП
Utility	ADCLab	осциллограф с режимом анализа спектра
	DskDma64	утилита непрерывного сбора большого количества данных на диск для плат, работающих по DMA
	OscView	утилита просмотра сохранённых на диск данных, полученных с помощью плат АЦП
	IrqDma	утилита мониторинга состояния  векторов прерываний и каналов DMA в Windows


ВАЖНО! Для того чтобы скомпилировать прилагаемые примеры необходимо прописать соответствующие пути к включаемым файлам, расположенным в каталоге ..\..\INTERFACES, в опциях используемого компилятора. Например, в среде Visual Studio надо выбрать пункт меню TOOLS\OPTIONS, далее в панели настроек выбрать закладку DIRECTORIES, в пункте “Show Directories for:” выбрать “Include files” и в списке “Directories” добавить строчку, например “C:\Program Files\LASDK\INTERFACES”. В среде Borland C++ Builder или Borland Delphi надо выбрать пункт меню Project\Options, далее в панели настроек выбрать закладку “Directories\Conditionals” и в пункте “Search Path” (Delphi) или “Include Path” (C++ Builder) добавить такую же строчку.
3. Описание интерфейса LAXXX.DLL для программирования на C++ и Object Pascal (OP).
3.1. Заголовочный файл констант для работы с драйвером – ADC_Const.h (ADC_Const.pas и ADC_Const.bas)
Этот заголовочный файл содержит все необходимые константы для работы с драйвером: константы для задания режимов работы, формирования управляющих слов, коды ошибок. Все константы и случаи их применения будут описаны ниже, в разделе, посвящённом классу IADCDevice.
 
3.2. Заголовочный файл класса фабрики DLL – IFactory.h (IFactory.pas).
Содержит описание абстрактного класса фабрики для поставляемых библиотек динамической компоновки. Поставляемые модули DLL содержат единственный экспортируемый объект – класс с названием “StaticFactory”. Метод “Create” этого класса создаёт один из реализованных в DLL объектов и возвращает на него ссылку.

Так выглядит прототип класса фабрики на C++ (включаемый файл ifactory.h):

struct  IFactory
{
void* Create(TCHAR* InterfaceName, void* pReserved);
};

А так на Object Pascal (модуль IFactory):

TIFactory = class
  public
    Function Create(InterfaceName: PChar; pReserved: Pointer): Pointer;
end;

Метод Create
Использование:
Получение указателя на объект IADCDevice из библиотеки динамической компоновки.
Синтаксис:
См. выше.
Параметры:
InterfaceName
Название интерфейса, указатель на который надо получить (некоторые поставляемые библиотеки динамической компоновки могут иметь несколько интерфейсов, например, библиотека zoomer.dll содержит интерфейсы “IOSC” и “IOSC1”). Если ссылку на интерфейс получить не удалось, то метод возвращает NULL.
pReserved
Зарезервировано для использования в будущем (для задания специфических параметров драйверу).
Возвращаемое значение:
Указатель на объект IADCDevice из библиотеки динамической компоновки драйвера LAXXX.
Описание:
-
Пример на C++:
. . .
IFactory*   pFact;
IADCDevice* pADC;
. . .
// Инициализация класса pFact (см. ниже в описании класса DllClient)
. . .
pADC = pFact.Create(“IADCDevice”, NULL);
if (!pADC)
{
	// Критическая ошибка
	cout << “Не могу получить интерфейс!” << endl;
	exit(1);
}
// Использование функций драйвера с помощью pADC
. . .

Пример на OP:
. . .
var
   Fact: TIFactory;
   ADC : TIADCDevice;
. . .
begin
     // Инициализация класса Fact (см. ниже в описании класса DllClient)
     . . .
     ADC := Fact.Create(‘IADCDevice’, nil);
     if ADC = nil then
     begin
	    // Критическая ошибка
	    Application.MessageBox(
              “Не могу получить интерфейс!”,
              “Ошибка!”, MB_OK or MB_ICONSTOP);
	    Exit;
     end;
     // Использование функций драйвера с помощью pADC
     . . .
end.
В целом картина на языке С++ выглядит так:
// драйвер
class Driver: public IADCDevice 
{
	// непосредственно код драйвера
};
. . .
class ...
{
public:
	void* __stdcall Create(TCHAR*, void*);
} StaticFactory;

void* __stdcall StaticFactory::Create(TCHAR*, void*)
{
	...
	Driver *pDriver = new Driver();
	if(pDriver) pDriver->AddRef();
	return (void*)pDriver;
}
...
// программа, использующая драйвер
...
IFactory *pStaticFactory = GetProcAddress(hLib, “StaticFactory”);
IADCDevice *pDriver = (IADCDevice *)pStaticFactory->Create(...);
...

3.3. Класс DLLClient. Работа с библиотеками динамической компоновки.
Класс, упрощает работу с библиотеками динамической компоновки. Содержит методы, позволяющие получить список установленных библиотек, а также загружать и выгружать их из адресного пространства Вашей программы.
Описание класса на C++ (включаемый файл dllclient.h):

class DllClient
{
       void*   LoadByPath(TCHAR const* szPath, char const* szExportName);

       void*   LoadRegistered(TCHAR const* szCompanyName,
                              TCHAR const* szProductName,
                              TCHAR const* szVersionName,
                              TCHAR const* szModuleName,
                              char const* szExportName = "StaticFactory");

       void    Free();

static TCHAR*  GetRegName(TCHAR* data, int size, int index,
                          TCHAR const* szCompanyName,
                          TCHAR const* szProductName,
                          TCHAR const* szVersionName);

static TCHAR*  GetInterfaceName(char* data, int size,
                                TCHAR const* szCompanyName,
                                TCHAR const* szProductName,
                                TCHAR const* szVersionName,
                                TCHAR const* szModuleName);
};
Описание класса на Object Pascal (модуль DllClient):

TDllClient = class
public
    constructor Create;

    function LoadByPath(szPath, szExportName: PChar): FARPROC;

    function LoadRegistered(
          	     CompanyName, ProductName, VersionName, ModuleName: string;
      	     szExportName: PChar): FARPROC;

    function GetRegName(var data: PChar; size, index: Integer;
                    CompanyName, ProductName, VersionName: string): Boolean;

    function GetInterfaceName(CompanyName, ProductName, 
                              VersionName, ModuleName: string): string;

    procedure FreeDll;
end;

Конструктор Create (только Object Pascal)
Использование:
Инициализация объекта TDllClient.
Синтаксис:
 Create;
Параметры:
-
Возвращаемое значение:
В соответствии с документацией Borland Delphi (TM) по языку Object Pascal – ссылка на создаваемый объект.
Описание:
Стандартный способ инициализации классов в Object Pascal.
Пример на OP:
. . .
var
   LAXXDllClient;
. . .
begin
     . . .
     LAXXDllClient := TDllClient.Create;
     // Использование класса DllClient
     . . .
end.
Загрузка DLL с указанием полного пути к файлу и получение ссылки на объект из этой библиотеки: метод LoadByPath (C++ и OP)
Использование:
Загрузка DLL при известном пути к её файлу на диске и получение ссылки на объект из неё.
Синтаксис:
 С++:
 void*    LoadByPath(TCHAR const* szPath, char const* szExportName);
OP:
 function LoadByPath(szPath, szExportName: PChar): FARPROC;
Параметры:
szPath
Путь и имя файла загружаемой DLL.
szExportName
Имя импортируемого объекта из загружаемой DLL.
Возвращаемое значение:
Ссылка на импортируемый объект из загруженной библиотеки динамической компоновки. 
Описание:
Этот метод используется методом LoadRegistered, поэтому нет необходимости и не рекомендуется использовать этот метод напрямую. При загрузке DLL её идентификатор (HANDLE) сохранятся «внутри» класса ((T)DllClient) и далее может быть использован только методом Free (FreeDll - OP) для выгрузки библиотеки из адресного пространства использовавшей его программы. Во всех приведённых в данном описании примерах из DLL импортируется класс IFactory (TIFactory).
Пример:
	 -
Загрузка DLL, зарегистрированной в реестре MS Windows 9X/Me и получение ссылки на объект из этой библиотеки: метод LoadRegistered (C++ и OP)
Использование:
Загрузка зарегистрированной в реестре DLL и получение ссылки на объект.
Синтаксис:
 С++:
 void*    LoadRegistered(TCHAR const* szCompanyName,
                               TCHAR const* szProductName,
                               TCHAR const* szVersionName,
                               TCHAR const* szModuleName,
                         char  const* szExportName);
OP:
 	 function LoadRegistered(CompanyName,
                               ProductName,
                               VersionName,
                               ModuleName: string;
      	             szExportName: PChar): FARPROC;
Параметры:
szCompanyName  (C++) или CompanyName (OP)
Название подраздела (обычно имя компании-изготовителя программного обеспечения) в разделе HKEY_LOCAL_MACHINE\Software. Для работы с поставляемым программным обеспечением рекомендуется использовать константу CompanyNameDRV из поставляемого заголовочного файла “REGKEY\VT_Drivers.ri” (модуль VT_Drivers – OP), которая содержит строку “Virtual Tools LTD”.
szProductName  (C++) или ProductName (OP)
Название подраздела (обычно название программного продукта) в разделе HKEY_LOCAL_MACHINE\Software\CompanyName. Рекомендуется использовать константу ProductNameDRV из файла “REGKEY\VT_Drivers.ri” (модуль VT_Drivers – OP), которая содержит строку “Drivers”.
szVersionName  (C++) или VersionName (OP)
Название подраздела (обычно номер или имя версии программного продукта) в разделе HKEY_LOCAL_MACHINE\Software\CompanyName\ProductName. Рекомендуется использовать константу VersionNameDRV из файла “REGKEY\VT_Drivers.ri” (модуль VT_Drivers – OP), которая содержит строку “1.0”.
szModuleName  (C++) или ModuleName (OP)
Название папки с информацией о драйвере или библиотеки динамической компоновки в разделе HKEY_LOCAL_MACHINE\Software\CompanyName\ProductName \VersionName. Для работы с поставляемыми драйверами в качестве этого параметра надо использовать имя драйвера. Возможные названия драйверов приведены в разделе 6 «Имена драйверов для различных плат».
szExportName
Имя импортируемого объекта из загружаемой DLL. По умолчанию (в программах на OP надо передавать в этом параметре nil) этот параметр равен “StaticFactory”. Это единственный объект, который можно импортировать из поставляемых DLL, за исключением “UniDriver.dll”.
Возвращаемое значение:
Ссылка на импортируемый объект из загруженной библиотеки динамической компоновки. 
Описание:
Этот метод используется для загрузки зарегистрированных в реестре DLL. При этом для неё должен быть определён строковый параметр Path, который содержит путь к файлу библиотеки на диске. Как зарегистрировать DLL (что делается с поставляемыми драйверами при установке автоматически) написано в разделе 3 «Процесс установки». Из всех поставляемых DLL, кроме UniDriver.dll импортируется класс IFactory (TIFactory), который имеет имя “StaticFactory”.
Пример на C++:
. . .
IFactory* LAxFactory =
    (IFactory*)LAxClient.LoadRegistered(CompanyNameDRV,
    	                                  ProductNameDRV,
                                        VersionNameDRV,
                                        “LAEMUL”);
. . .
Пример на OP:
. . .
var
   LaXXfact: TIFactory;
   dllcl   : TDllClient;
begin
     . . .
     LaXXfact := dllcl.LoadRegistered(CompanyNameDrv,
                                      ProductNameDrv,
                                      VersionNameDrv,
                                      DrvName,
                                      nil);
     . . .
end;
Выгрузка DLL из адресного пространства приложения: метод Free (C++) или FreeDll (OP)
Использование:
Выгрузка загруженной библиотеки динамической компоновки из памяти.
Синтаксис:
С++:
 void      Free();
OP:
 procedure FreeDll;
Параметры:
-
Возвращаемое значение:
-
Описание:
Данный метод выгружает ранее загруженную DLL из адресного пространства приложения. После вызова этого метода использование импортированного из неё интерфейса невозможно. При этом указатель на этот объект не обнуляется, что может повлечь исключение защиты Windows или неправильную работу приложения.
Пример на C++:
. . .
LAXXDllClient.Free();
// Завершение работы приложения или загрузка другого драйвера или библиотеки
. . .
Пример на OP:
. . .
LAXXDllClient.FreeDll;
// Завершение работы приложения или загрузка другого драйвера или библиотеки
. . .
Получение имени драйвера (названия папки реестра): метод GetRegName (C++  и OP)
Использование:
Получение имён доступных драйверов для плат ЛА-XXX.
Синтаксис:
С++:
 static TCHAR*  GetRegName(TCHAR* data, int size, int index,
                                 TCHAR const* szCompanyName,
                                 TCHAR const* szProductName,
                                 TCHAR const* szVersionName);
OP:
 function GetRegName(var data: PChar; size, index: Integer;
                     CompanyName, ProductName, VersionName: string): Boolean;
Параметры:
data
Буфер под строку, куда будет записано имя драйвера.
size
Максимальный размер буфера для имени драйвера.
index
Номер драйвера в подразделе, задаваемом следующими параметрами.
szCompanyName, szProductName, szVersionName (C++)
или
CompanyName, ProductName, VersionName (OP)
Задают подраздел реестра Windows, который должен содержать драйверы для платы ЛА-XXX: “HKEY_LOCAL_MASHINE\Software\szCompanyName\szProductName\ szVesionName”. Более подробное описание этих параметров смотрите в описании параметров метода LoadRegistered. 
Возвращаемое значение:
C++ - указатель на ASCIIZ строку, содержащую имя драйвера или NULL, если с драйвера с указанным индексом не существует.
OP – True, если удалось получить имя драйвера с указанным индексом, иначе False.
Описание:
Возвращает имя драйвера из указанного подраздела реестра Windows. Для поставляемого программного обеспечения это “HKEY_LOCAL_MACHINE\Software\Virtual Tools LTD\Drivers\1.0”. 
Пример на C++:
. . .
DllClient dllcl;
char drv_name[100][20];
for ( int n = 0; n < 100; ++n)
    if ( dllcl.GetRegName(drv_name[n], 20, n,
                          CompanyNameDRV,
                          ProductNameDRV,
                          VersionNameDRV) == 0) break;
cout << “Installed drivers:” << endl;
for ( int i = 0; i < n; cout << drv_name[i] << endl,i++);
. . .
Пример на OP:
. . .
var
   n: Integer;
   s: String;
   . . .
begin
. . .
s := StrAlloc(255);
n := 0;
while LAxClient.GetRegName(s, 255, n,
                           CompanyNameDRV,
                           ProductNameDRV,
                           VersionNameDRV) do
begin
  Inc(n);
  DriversComboBox.Items.Add(String(s));
end;
DriversComboBox.ItemIndex := 0;
. . .
end;
Получение названий поддерживаемых драйвером интерфейсов: метод GetInterfaceName (C++ и OP)
Использование:
Получение названий поддерживаемых драйвером интерфейсов.
Синтаксис:
C++:
static TCHAR*  GetInterfaceName(char* data, int size,
                                TCHAR const* szCompanyName,
                                TCHAR const* szProductName,
                                TCHAR const* szVersionName,
                                TCHAR const* szModuleName);
OP:
function GetInterfaceName(CompanyName, ProductName, 
                          VersionName, ModuleName: string): string;
Параметры:
data (только C++)
Адрес буфера, куда будет помещён список поддерживаемых драйвером интерфейсов.
size (только C++)
Максимальный размер возвращаемой строки.
szCompanyName, szProductName, szVersionName (C++)
или
CompanyName, ProductName, VersionName (OP)
Задают подраздел реестра Windows, который должен содержать драйверы для платы ЛА-XXX. Более подробное описание этих параметров см. в пояснениях для предыдущих методов.
Возвращаемое значение:
Указать на буфер (С++) или строка (OP), куда был помещён список поддерживаемых драйвером интерфейсов. Названия интерфейсов разделяются запятыми, возможные пробелы надо пропускать. Если произошла ошибка при получении названий интерфейсов (было неправильно указано имя драйвера), то метод возвратит NULL (C++) или пустую строку (‘’ - OP).
Описание:
Метод может быть использован для определения поддерживаемых драйвером интерфейсов, в частности, для предоставления пользователю возможности выбрать из списка драйвер для работы с конкретной платой, то есть для создания полностью аппаратно независимых программ, так все драйверы поддерживают единый интерфейс. Физически названия интерфейсов – это имена импортируемых из DLL классов. Данный метод возвращает значение строкового параметра “UIName” для заданного драйвера, который записывается в реестр Windows в папку драйвера при регистрации DLL.
Пример на C++:
. . .
DllClient LAxClient;
. . .
char IntName[20];
if ( LAxClient.GetInterfaceName(IntName, 20,
    CompanyNameDRV, ProductNameDRV, VersionNameDRV, szSomeName) )
  if ( strtcmp(intName, “IADCDevice”) )
    cout << “This driver suppots common ADC interface” << endl;
. . .
Пример на OP:
. . .
var
. . .
   IntName: String;
   LAxClient: TDllClient;
. . .
begin
. . .
  IntName := LAxClient.GetInterfaceName(
    CompanyNameDRV, ProductNameDRV, VersionNameDRV, SomeName);
  if intName = 'IADCDevice' then
    Application.MessageBox(
      ‘This driver suppots common ADC interface’,
      ‘message’, 
      MB_OK or MB_ICONINFORMATION);
. . .

Загрузка драйвера АЦП, зарегистрированного в реестре MS Windows 9X/Me и получение ссылки на интерфейс: метод LoadDriver (C++)
Использование:
Загрузка зарегистрированного в реестре драйвера и получение ссылки на стандартный интерфейс для управления платами (см. ниже).
Синтаксис:
 С++:
void*   LoadDriver(TCHAR* szModuleName,
                   TCHAR* szInterfaceName=0,
                    void* lpParam=0)
Параметры:
szModuleName
Имя драйвера. Возможные названия драйверов приведены в разделе 6 «Имена драйверов для различных плат».
InterfaceName
Как видно из описания, необязательный параметр. Это название интерфейса, указатель на который надо получить. На данный момент драйверы поддерживают  только один интерфейс с названием “IADCDevice”. Именно это название интерфейса используется по умолчанию.
lpParam
Зарезервировано для использования в будущем (для задания специфических параметров драйверу).
Возвращаемое значение:
Указатель на объект IADCDevice из библиотеки динамической компоновки драйвера LAXXX или 0 (NULL), если не удалось загрузить указанный драйвер.
Описание:
Этот метод используется для загрузки зарегистрированных в реестре поставляемых в комплекте с платами АЦП драйверов. Как не трудно догадаться или посмотреть в исходных текстах, этот метод заменяет последовательный вызов сначала метода LoadRegistered, а затем  Create класса IFactory (см. выше).
Пример на C++:
. . .
DllClient LAxClient;
IADCDevice* pADC = LAxClient.LoadDriver(“LAVP”);
. . .
или
. . .
DllClient LAxClient;
IADCDevice* pADC;
IFactory* LAxFactory;

LAxFactory = (IFactory*)LAxClient.LoadRegistered(CompanyNameDRV,
                                                 ProductNameDRV,
                                                 VersionNameDRV, 
                                                 “LAVP”);
if(LAxFactory)
IADCDevice* pADC = (IADCDevice*)LAxFactory->Create("IADCDevice", 0);
. . .

3.4. Заголовочный файл класса интерфейса драйвера
Интерфейс с драйвером LAXXX.DLL описан в файле "IADCDevice.h(pas)". Он представляет собой абстрактный класс.

struct  IADCDevice
{
      unsigned	AddRef();
 	unsigned 	Release();
 	int      	Setup(int    baseAdr, 
                        int    DRQ, 
                        int    IRQ, 
                        HANDLE hEvent);
 	int		Test();
 	int 		Init(int mode, ADCParametersBase*, float*);
 	int         Start();
 	void        Stop();
 	int         GetData(int   mode, 
                          void* pAdr, 
                          int   size, 
                          int   offset);
 	int         PortIO(int mode, void* pAdr, int size);
 	int         Get(int mode, void* value);
    	void        ClearInterrupt();
};

Для создания экземпляра объекта IADCDevice необходимо выполнить     следующие действия:

#include    <windows.h>
#include    <tchar.h>

#include    "IFactory.h"
#include    "DllClient.h"
#include    "REGKEY\VT_Drivers.ri"
#include    "IADCDevice.h"

/////////////////////////////////////////////////////////
//  Читает из системного реестра информацию о драйверах. 
//  Эту информацию можно использовать для того, чтобы 
//  загрузить тот или иной драйвер.

    char dev[10][20];
    DllClient LAxClient;
    for(int n=0; n<10; ++n)
        if(!LAxClient.GetRegName(dev[n], 20, n, 
                                 CompanyNameDRV, 
                                 ProductNameDRV, 
                                 VersionNameDRV)) break;
    if(n == 0)
    {
//  Нет ни одного драйвера
        return;
    }

//  Загружает первый из зарегистрированных драйверов
    IFactory* LAxFactory =
    (IFactory*)LAxClient.LoadRegistered(CompanyNameDRV,
    	                                  ProductNameDRV,
                                        VersionNameDRV,
                                        dev[0]);
    if (LAxFactory == 0)
    {
//  Драйвер не загрузился. Это возможно из-за его отсутствия или отсутствия
//  IntDma.DLL или драйвер не был зарегистрирован с помощью
//  "regsvr32.exe LAXXX.dll"
        return;
    }
//  Собственно LAxClient больше не нужен, поскольку в каждой DLL существует
//  одна фабрика объектов. Но с помощью DllClient::Free можно 
//  выгрузить из памяти драйвер LAXXX.dll.

//  Получение интерфейса "IADCDevice".
    IADCDevice* pADC = (IADCDevice*)LAxFactory->Create(_T("IADCDevice"), 0);
    if(pADC == 0)
    {
//  Объект не создан. Скорее всего, модуль не поддерживает этот интерфейс.
        return;
    }
//  Значение счетчика ссылок во вновь созданном объекте равно 1.
//  Когда Вы передаете кому-либо указатель нужно вызывать метод AddRef() 
//  который увеличивает счетчик ссылок на 1, когда указатель больше 
//  не нужен, нужно вызывать c1->Release().

//  Теперь можно вызывать функции интерфейса "IADCDevice".
{
//WORK WORK WORK WORK WORK WORK WORK WORK WORK WORK WORK WORK WORK WORK 
}

//  Когда интерфейс больше не нужен, нужно освободить его вызвав 
//  метод Release(). При этом освободятся все ресурсы которые 
//  были захвачены.
    pADC->Release();
/////////////////////////////////////////////////////

3.5. Описание класса интерфейса драйвера
Метод AddRef
Использование:
Увеличение счетчика ссылок на объект IADCDevice при передаче указателя на него в другой модуль.
Синтаксис:
unsigned AddRef(void);
Параметры:
-
Возвращаемое значение:
Текущее значение счетчика ссылок на объект.
Описание:
Метод увеличивает счётчик ссылок на объект на 1.
Пример на C++:
. . .
IADCDevice* pADC;
. . .
// Инициализация объекта IADCDevice
. . .
pADC->AddRef();
SomeWierdProc(pADC);
. . .
pADC->Release();
}

SomeWierdProc(IADCDevice* myADC)
{
	. . .
	// Использование указателя myADC
	myADC->Release();
}

Метод Release
Использование:
Уменьшение счетчика ссылок на объект IADCDevice при завершении его использования.
Синтаксис:
unsigned Release(void);
Параметры:
-
Возвращаемое значение:
Текущее значение счетчика ссылок на объект.
Описание:
Метод уменьшает счетчик ссылок на объект на 1, при достижении счётчиком  значения 0 объект уничтожается.
Пример на C++:
Смотрите пример к предыдущему методу.
Метод Setup
Использование:
Настройка параметров платы.
Синтаксис:
 int Setup(int baseAdr, int DRQ, int IRQ, HANDLE hEvent);
Параметры:
BaseAdr
Базовый адрес платы в пространстве ввода/вывода. Для плат Plug’n’Play (то есть PCI) и внешних устройств, подключаемых, например, к параллельному порту компьютера, в качестве базового адреса передаётся номер платы (устройства). Для плат с интерфейсом PCI номер определяется следующим образом: плата №1 находится в самом верхнем слоте PCI  (ближайшем к слоту AGP), следующая такая же плата будет иметь №2 и так далее. Для внешних устройств на параллельный порт в качестве в параметре BaseAdr следует передавать номер порта.
DRQ
Номер канала DMA. Если не надо или нельзя использовать DMA, тогда надо задать этот параметр равным 0, при этом канал(ы) DMA не захватываются.
IRQ
Номер прерывания. Для плат с интерфейсом PCI в качестве номера прерывания надо передать 1. К номеру прерывания при помощи побитовой операции «или» можно добавить флаг ADC_SETUP_IRQ_MESSAGE. В зависимости от присутствия этого флага следующий параметр будет восприниматься либо как дескриптор события (Event), либо как указатель на структуру Interrupt_Message. Если не надо или нельзя использовать прерывания, тогда в этом параметре надо передать 0, тогда ни одно прерывание не захватывается.
hEvent
Дескриптор события для реакции на прерывание, если не установлен флаг ADC_SETUP_IRQ_MESSAGE (определён в заголовочном файле ADC_Const.h). Событие для реакции на прерывание может быть создано следующим образом:
HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
Иначе этот параметр интерпретируется как указатель на структуру следующего вида:
struct  Interrupt_Message
{
    HWND        m_hWnd;
    UINT        m_uMessage;
    LPARAM      m_uLParam;
};
поля которой имеют следующие значения:
m_hWnd
Дескриптор окна, которое будет получать сообщение при происхождении прерывания, чаще всего это должно быть главное окно приложения.
m_uMessage
Сообщение, которое должно генерироваться при происхождении прерывания, точнее его код, который можно получить следующим способом:
1.	Простой метод, но применим, если сообщение используется главным окном приложения:
. . .
#define ANY_CONSTANT    123
#define WM_IRQ_HAPPENED WM_USER + ANY_CONSTANT
. . .
2.	Более сложный, но гарантирующий отсутствие конфликтов метод:
. . .
const char* szIrqMsgName = “_My_Very_Special_Irq_Message_Name_”;
. . .
UINT m_uIrqMsg = RegisterWindowMessage(szIrqMsgName);
if( m_uIrqMsg == 0 )
{
	// сообщение об ошибке
	exit (1);
}
// можно использовать значение переменной m_uIrqMsg для передачи функции
// Setup, а затем для обработки сообщения с таким кодом
. . .
m_uLParam
Значение параметра LParam, которое будет передаваться вместе с сообщением о прерывании.
Возвращаемое значение:
Если параметры платы настроены успешно, метод возвращает 1.
Если произошла ошибка, то возвращается её код. Возможные коды ошибок (см. файл ADC_Const.h):

Значение	Описание
ADC_ERROR_INVALIDBASE	Недопустимый базовый адрес
ADC_ERROR_INVALIDIRQ	недопустимый номер IRQ
ADC_ERROR_INVALIDDRQ	недопустимый номер канала DMA
ADC_ERROR_DRQ_ALLREADY_USED	канал DMA занят
ADC_ERROR_IRQ_ALLREADY_USED	линия прерывания занята
ADC_ERROR_VXD_NOTLOADED	нет необходимого IntDMA32.VxD
ADC_ERROR_VXD_INVALIDVERSION	IntDMA32.VxD есть, но не тот
Общие коды ошибок
ADC_ERROR_NOTSUPPORTED	функция не поддерживается
ADC_ERROR_NOTINITIALIZE	драйвер не инициализирован (не указан базовый адрес)
ADC_ERROR_INVALIDPARAMETERS	недопустимые значения параметров

Описание:
Метод задает базовый адрес платы baseAdr, номер используемого канала ПДП DRQ и номер используемой линии прерывания IRQ. Для некоторых плат можно задать два канала DMA. В этом случае в младшие 8 битов нужно поместить номер первого используемого канала DMA, в следующие 8 битов номер второго используемого канала. Если Вы задали номер прерывания, то нужно обязательно задать параметр hEvent. 
Основными вариантами использования метода Setup являются:
1. Освобождение ресурсов. Если Вы вызываете

pADC->Setup(0, 0, 0, 0);

то все ранее захваченные ресурсы освобождаются, то есть если указать нулевой номер прерывания или канала DMA то соответствующие ресурсы не захватываются.
2. Работа с платой по сигналу готовности:

int base = . . .;
pADC->Setup(base, 0, 0, 0);

в данном случае драйверу передаётся только базовый адрес порта ввода вывода, который будет использоваться для управления платой. 
3. Использование прерываний:
а) реакция на прерывание с использованием объекта Windows API Event:

int base = . . .;
int irq  = . . .;
int drq  = . . .;
HANDLE hEvent = CreateEvent( NULL, FALSE, FALSE, NULL);
pADC->Setup(base, drq, irq, hEvent);

б) обработка прерываний при помощи сообщений:

#define WM_LOCAL_INT_HAPPENED WM_USER + 101
. . .
int base = . . .;
int irq  = . . .;
int drq  = . . .;
Interrupt_Message ir;
ir.m_hWnd     = hWnd;
ir.m_uMessage = WM_LOCAL_INT_HAPPENED;
ir.m_uLParam  = 0;
pADC->Setup(base, drq, irq | ADC_SETUP_IRQ_MESSAGE, &ir);

Данный метод может не производить обращений к плате, а  только настраивать драйвер на работу с платой по заданным параметрам. Поэтому, его успешное выполнение не гарантирует корректной работы в дальнейшем, а только гарантирует получение системных ресурсов для работы с платой.

Пример на C++:
. . .
IADCDevice* pADC;
. . .
// Инициализация объекта IADCDevice
. . .
// Создаём событие для реакции на прерывания:
HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
// Задаём параметры платы:
// baseAdr = 0x320
// drq = 7
// irq = 10
int error = pADC->Setup(0x320, 7, 10, hEvent);
if (error <= 0)
{
// Обработка ошибки
}
. . .
Метод Test
Использование:
Проверка наличия платы. Не рекомендуется использовать этот метод для плат, не позволяющих безопасно определить их тип без использования операций записи в порты ввода-вывода. При указании неправильного базового адреса в методе Setup,  это может привести к нарушению работы устройства, использующего указанный адрес порта.
Синтаксис:
int Test(void);
Параметры:
-
Возвращаемое значение:
Если плата установлена, метод возвращает 1. В случае ошибки или отсутствия платы возвращает 0 или ADC_ERROR_NOTINITIALIZE - драйвер не инициализирован (не указан базовый адрес).
Описание:
Метод проверяет наличие платы по указанному, при вызове метода Setup, базовому адресу.
Пример на C++:
. . .
// См. предыдущий пример
. . .
if ( pADC->Test() != 1 )
{
	// Платы нет – обработка ошибки
}
. . .	 
Метод Init
Использование:
Установка параметров измерения.
Синтаксис:
 int Init(int mode, ADCParametersBase* param, float* freq);
Параметры:
mode
Параметр, определяющий требуемый режим работы функции (см. файл ADC_Const.h):

Значение	Описание
ADC_INIT_MODE_CHECK	Производится проверка значений параметров структуры param. Неправильные значения корректируются. Вы можете использовать структуру для дальнейшего задания параметров измерений
ADC_INIT_MODE_INIT	Происходит задание параметров последующего измерения

freq 
Указатель на место, куда будет записана фактическая частота следования данных. Это значение можно использовать для определения времени измерения. Если задается NULL, то значение не возвращается.

param 
Структура данных, описывающая параметры измерения. Может содержать данные в форматах ADCParametersDMA, ADCParametersDMA1, ADCParametersSINGLE, ADCParametersMEMORY, ADCParametersDMAEX или ADCParametersTimer (см. файл IADCDevice.h).
Эти структуры наследуют базовую структуру ADCParametersBase для возможности распознавания данным методом, какие именно данные он получает. Она имеет следующий вид:

struct  ADCParametersBase
{
    int m_nType;
    int m_nSizeOf;
};
m_nType
Определяет тип передаваемой структуры.

m_nSizeOf
Определяет размер передаваемой структуры.

Подробное описание передаваемых структур для настройки желаемых параметров измерений:

?	Режим передачи с использованием DMA, поддерживается платами ЛА-1.5, ЛА-2, ЛА-2М2(М3), ЛА-3, ЛА-4, ЛА-7, ЛА-8, ЛА-12, ЛА-14, ЛА-20, ЛА-ADSP. Частота дискретизации преобразуется в значения делителя и режима таймера драйвером:

struct  ADCParametersDMA : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_DMA_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersDMA)
// ---------------------------
    int      m_nStartOf;        // источник сигнала запуска преобразования
    int      m_nIntOf;          // источник прерываний

    int      m_nDMABlockSize;   // размер блока данных для передачи по DMA
    int      m_nDMAMode;        // режим работы DMA

    float    m_fFreqStart;      // частота дискретизации или кадров
    int      m_nTimerStart;     // номер канала таймера 
    float    m_fFreqPack;       // частота дискретизации внутри кадра
    int      m_nTimerPack;      // номер канала таймера
    int      m_nFirstChannel;   // номер первого канала и
    int      m_nChannelNumber;  // число каналов в режиме автосканирования
    int      m_nGain;           // коэффициент усиления для каждого канала      

    ADCParametersDMA();         // конструктор – автоматически устанавливает
                                // два первых параметра (m_nType и m_nSizeOf) 
} 
m_nStartOf
Параметр может принимать одно из следующих значений (см. файл ADC_Const.h):

Значение	Описание
ADCPARAM_START_PROGRAMM	Программный сбор одиночных значений («в ручную» - программый запуск преобразований)
ADCPARAM_START_TIMER	Сбор блока с запусками от внутреннего таймера
ADCPARAM_START_EXT	Сбор блока с запусками от внешнего источника
   
 m_nIntOf
параметр может принимать одно из следующих значений (см. файл ADC_Const.h):

Значение	Описание
ADCPARAM_INT_READY	Разрешается прерывание по концу преобразования
ADCPARAM_INT_TC	Разрешается прерывание по концу передачи DMA
ADCPARAM_INT_EXT	Разрешается прерывание от внешнего источника

 m_nDMABlockSize
Размер блока для передачи по каналу DMA, этот параметр может принимать значения  от 1 до 65536 слов (для всех плат, поддерживающих работу по DMA или имеющих локальную оперативную память, размер слова составляет 2 байта).
  
 m_nDMAMode
Режим передачи данных по DMA:

Значение	Описание
0	Одиночная передача по каналу DMA
1	Режим с авто инициализацией


 m_nTimerStart
Номер канала таймера, который задает частоту запусков АЦП, или  частоту кадров в режиме кадрового сбора.

 m_nTimerPack
Номер канала таймера, который задает частоту запусков АЦП внутри  кадра для режима кадрового сбора. Если номер таймера меньше 0, то режим кадрового сбора не используется. 
Для этих двух параметров возможны следующие значения:

Значение	Описание
ADCPARAM_TIMER0	0 канал таймера
ADCPARAM_TIMER1	1 канал таймера
ADCPARAM_TIMER2	2 канал таймера

m_fFreqStart
Частота (в Hz) запусков АЦП, или частота кадров в режиме                                        кадрового сбора.

m_fFreqPack
Частота (в Hz) запусков АЦП внутри кадра для режима кадрового сбора. Если частота меньше или равна 0, то режим кадрового сбора не используется.

m_nFirstChannel
Номер первого аналогового канала в режиме авто сканирования.

m_nChannelNumber
Количество аналоговых каналов в режиме авто сканирования.

m_nGain
Коэффициент усиления для каждого аналогового канала.

?	Режим передачи с использованием DMA, прямое программирование таймеров для запусков преобразований (поддерживается драйверами для тех же плата, что и для предыдущей структуры):

struct  ADCParametersDMA1 : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_DMA1_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersDMA1)
// ---------------------------
    int      m_nStartOf;        // источник сигнала запуска преобразования
    int      m_nIntOf;          // источник прерываний

    int      m_nDMABlockSize;   // размер блока данных для передачи по DMA
    int      m_nDMAMode;        // режим работы DMA

    float    m_fFreq;           // частота сбора кадров 
    int      m_nTimer0Delay;    // делитель для 0-ого канала таймера 
    int      m_nTimer0Mode;     // режим 0-ого канала таймера 
    int      m_nTimer1Delay;    // делитель для 1-ого канала таймера
    int      m_nTimer1Mode;     // режим 1-ого канала таймера
    int      m_nTimer2Delay;    // делитель для 2-ого канала таймера 
    int      m_nTimer2Mode;     // режим 2-ого канала таймера 

    int      m_nFirstChannel;   // номер первого канала и
    int      m_nChannelNumber;  // число каналов в режиме авто сканирования
    int      m_nGain;           // коэффициент усиления для каждого канала      

    ADCParametersDMA1();        // конструктор – автоматически устанавливает
                                // два первых параметра (m_nType и m_nSizeOf) 
}
Описание параметров, совпадающих с параметрами в структуре ADCParametersDMA, смотрите выше.

m_nTimer0Delay, m_nTimer1Delay, m_nTimer2Delay
Делители для 0, 1 и 2 каналов таймера соответственно (см. описание к плате). Если задать значение такого параметра равным –1, то соответствующий канал не будет использоваться (см. описание программирование микросхемы i8254 в описании к плате).

m_nTimer0Mode, m_nTimer1Mode, m_nTimer2Mode
Режимы 0, 1 и 2 каналов таймера (см. описание программирование микросхемы i8254 в описании к плате).

?	ADCParametersTimer позволяет запрограммировать любой канал таймера в любой  режим и занести в него любой счетчик. Данную структуру поддерживают платы, имеющие таймер как для управления АЦП (то есть задания частоты дискретизации), так и для управления цифровым портом(-ами) ввода/вывода. Программирование таймера осуществляется «на лету», без остановки текущего измерения:

struct  ADCParametersTimer : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_TIMER_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersTimer)
// ---------------------------
    int      m_nTimer;          // номер канала таймера
    int      m_nTimerDelay;     // делитель и
    int      m_nTimerMode;      // режим программируемого канала таймера

    ADCParametersTimer();       // конструктор – автоматически устанавливает
                                // два первых параметра (m_nType и m_nSizeOf)
}
Данная структура используется для программирования одного таймера, но таким же образом, как это делается при помощи структуры ADCParametersDMA1 для всех таймеров. Поэтому назначение одноимённых параметров этих структур аналогичное. 

m_nTimer
Задаёт номер программируемого канала таймера, возможные значения:

Значение	Описание
ADCPARAM_TIMER0	0 канал таймера
ADCPARAM_TIMER1	1 канал таймера
ADCPARAM_TIMER2	2 канал таймера

m_nTimerDelay, m_nTimerMode
Задают соответственно делитель и режим для выбранного канала таймера (см. описание программирование микросхемы i8254 в описании к плате).

?	Задание параметров для одиночного преобразования (без использования DMA), поддерживается драйверами для плат ЛА-1.5, ЛА-2, ЛА-3, ЛА-4, ЛА-7, ЛА-8, ЛА-12, ЛА-12, ЛА-и24:

struct ADCParametersSINGLE : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_SINGLE_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersSINGLE)
// ---------------------------
    int      m_nIntOf;          // источник прерываний

    int      m_nFirstChannel;   // номер первого канала и
    int      m_nChannelNumber;  // число каналов в режиме авто сканирования
    int      m_nGain;           // коэффициент усиления для каждого канала      

    ADCParametersSINGLE();      // конструктор – автоматически устанавливает
                                // два первых параметра (m_nType и m_nSizeOf)
}

m_nIntOf
Задаёт источник прерываний, может принимать одно из следующих значений:

Значение	Описание
0	Прерывания не используются. Получение данного по установке бита готовности.
ADCPARAM_INT_READY	Разрешается прерывание по концу преобразования
ADCPARAM_INT_EXT	Разрешается прерывание от внешнего источника

m_nFirstChannel, m_nChannelNumber, m_nGain
Аналогичны одноимённым параметрам из структуры ADCParametersDMA.

?	Задание параметров преобразования для плат с памятью, то есть ЛА-н10МX, ЛА-н24, ЛА-н25, ЛА-н05, ЛА-БП, ЛА-н10МXPCI, ЛА-н20PCI, ЛА-н02:

struct ADCParametersMEMORY : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_MEMORY_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersMEMORY)
// ---------------------------
    int      m_nStartOf;        // источник сигнала запуска преобразования

    float    m_fFreq;           // частота дискретизации
    int      m_nBufferSize;     // количество собираемых данных (в словах)
    int      m_nBeforeHistory;  // значение от 0 до 7 (см. описание к плате)
    int      m_nDelta[2];       // смещение для каждого канала (-128..127)
    int      m_nGain[2];        // коэффициенты усиления для каждого канала
    int      m_nControl;        // управляющее слово
    int      m_nSyncLevel;      // уровень синхронизации (-128..127)

    ADCParametersMEMORY();      // конструктор – автоматически устанавливает
                                // два первых параметра (m_nType и m_nSizeOf)
}

m_nStartOf
Параметр, определяющий источник сигнала для запуска преобразований, может принимать одно из следующих значений:

Значение	Описание
ADCPARAM_START_PROGRAMM	Запуск преобразований с выключенным режимом синхронизации
ADCPARAM_START_EXT	Сбор блока с запусками от внешнего источника
ADCPARAM_START_COMP	Старт от компаратора (при превышении некоторого уровня)

m_fFreq
Частота дискретизации, подгоняется к наиболее близкому значению из допустимых.

m_nBufferSize
Количество собираемых данных в словах, подгоняется к наиболее близкому    значению из допустимых величин.

m_nBeforeHistory
Значение от 0 до 7, код размера предыстории (см. описание к плате).

m_nDelta
Массив из двух элементов, задающих смещения по каждому аналоговому каналу. Допустимые значения находятся в диапазоне от -128 до 127 (см. описание к плате), при выходе за указанный диапазон значения «усекаются» до предельных величин.

m_nGain
Массив из двух элементов, задающих коэффициенты усиления по каждому аналоговому каналу. Допустимые значения 1, 2, 5 или 10 для платы ЛА-н10МX, возможные значения для других плат смотрите в их описаниях.

m_nControl
Управляющее слово, которое представляет собой комбинацию (побитовой операцией «или») из следующих значений:

Значение	Описание
ADC_CONTROL_DIFS*	«Закрыть» вход внешней синхронизации (входные цепи при помощи реле пере коммутируются так, что входной сигнал проходит через конденсатор, таким образом, удаляется постоянная составляющая из входного сигнала)
ADC_CONTROL_DIF0*	«Закрыть» вход канала 0
ADC_CONTROL_DIF1*	«Закрыть» вход канала 1
ADC_CONTROL_M2**	Режим FREQ*2 (удвоение частоты дискретизации, два канала работают последовательно)
ADC_CONTROL_ESW	Запрещение переключения частоты дискретизации по окончании записи предыстории в момент срабатывания схем синхронизации (см. описание к плате), если этот флаг не установлен, то произойдёт переключение частоты дискретизации с заданной на Fmax (максимальную): например, на 50 МГц для ЛА-н10МX и на 100 МГц для ЛА-н05 соответственно
ADC_CONTROL_FSW	Применяется только при НЕ установленном флаге ADC_CONTROL_ESW. Задаёт переключение частоты дискретизации с заданной на Fmax/8 по окончании записи предыстории в момент срабатывания схем синхронизации: например, на 6,25 МГц для ЛА-н10МX и на 12,5 МГц для ЛА-н05 соответственно
ADC_CONTROL_SYNC_FRONT	Синхронизация по фронту (положительному перепаду) входного сигнала
ADC_CONTROL_SYNC_DECLINE	Синхронизация по спаду (отрицательному перепаду) входного сигнала
ADC_CONTROL_SYNC_TTL	Синхронизация от внешнего источника
ADC_CONTROL_SYNC_COMPARATOR	Синхронизация от внутреннего компаратора
ADC_CONTROL_SYNC_CH1	Синхронизация от входного сигнала 1 канала
ADC_CONTROL_SYNC_CH0	Синхронизация от входного сигнала 0 канала

* - только для ЛА-н10МX;
** - только ЛА-н10МX, ЛА-н05;

m_nSyncLevel   
Уровень синхронизации. Допустимые значения находятся в диапазоне от -128 до 127 (см. описание к плате), при выходе за указанный диапазон значения «усекаются» до предельных величин. 

?	Расширенная структура параметров для сбора данных по DMA для драйверов плат, имеющих расширенную функциональность (ЛА-1.5):

struct  ADCParametersDMAEX : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_DMAEX_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersDMAEX)
// ---------------------------
    int*     m_pnGains;         // коэффициенты усиления для каждого канала
    int*     m_pnChannels;      // номера каналов
    int      m_nSize;           // количество каналов
    int      m_nControl;        // управляющее слово
    int      m_nSyncLevel[2];   // уровни синхронизации

    ADCParametersDMAEX();       // конструктор – автоматически устанавливает
                                // два первых параметра (m_nType и m_nSizeOf)
}

m_nGains
Массив из m_nSize элементов, содержащий коэффициенты усиления для каждого канала индивидуально.

m_nChannels
Массив из m_nSize элементов, содержащий номера каналов, для которых будут заданы соответствующие коэффициенты усиления.

m_nControl
Управляющее слово.

m_nSyncLevel
Уровни синхронизации.

?	Структура параметров для низкоуровневого программирования устройства через виртуальные регистры. Допускает запись и чтение только в разрешенные разряды регистров платы. (В существующей версии поддерживается только платами LPT и PCI):

struct  ADCParametersPORT : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_PORT_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersPORT)
// ---------------------------
    int         m_nOperation;	

    unsigned    m_nPortNumber;
    unsigned    m_nPortValue; 
    unsigned    m_nPortNANDMask;  
    unsigned    m_nPortORMask;  
};

m_nOperation
Тип операции с портом ввода/вывода. Значение должно быть одним из следующих:

Значение	Описание
ADC_PORT_READ	Чтение из виртуального регистра
ADC_PORT_WRITE	Запись в виртуальный регистр
ADC_PORT_MASK	Очистка или установка в 1 отдельных битов регистра по выбору
Reg = m_nPortValue & ~(m_nPortNANDMask) |     m_nPortORMask

m_nPortNumber
Номер виртуального регистра устройства.

m_nPortValue
Значение, выводимое или считываемое из регистра устройства. При операции чтения в это поле заносится значение указанного виртуального регистра.
	
m_nPortNANDMask
NOT_AND маска для операции ADC_PORT_MASK
	
m_nPortORMask
Значение OR для операции ADC_PORT_MASK
     
?	Структура параметров для низкоуровневого программирования счетчиков таймеров (в существующей версии поддерживается только платами LPT и PCI):

struct  ADCParametersPORT_TIMER : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_PORT_TIMER_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersPORT_TIMER)
// ---------------------------
    int	    m_nOperation;        

    unsigned    m_nTimerNumber;
    unsigned    m_nTimerMode;  
    unsigned    m_nTimerValue; 
};

m_nOperation
Определяет, какое действие нужно произвести со счетчиком таймером. Значение должно быть одним из следующих:

Значение	Описание
ADC_PORT_TIMER_READ	Чтение значения счетчика таймера
ADC_PORT_TIMER_WRITE	Программирование отдельного канала таймера
	
m_nTimerNumber
Номер канала таймера.

m_nTimerMode
Код режима таймера. Число в диапазоне от 0 до 5. (как у микросхемы i8253).

m_nTimerValue
Значение, заносимое или считываемое из счетчика таймера. При операции чтения в это поле заносится значение требуемого счетчика таймера.
 
	
?	Структура параметров для низкоуровневого программирования DMA передачи (в существующей версии поддерживается только платами LPT и PCI):

struct  ADCParametersPORT_DMA : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_PORT_DMA_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersPORT_DMA)
// ---------------------------
    int         m_nOperation;        

    unsigned    m_nDMASize;    
    unsigned*   m_pInterruptLabel; 
    short*      m_pDMABuffer;     
};

m_nOperation
Разрешает или запрещает передачу DMA. Программируется контроллер DMA передачи расположенный на плате, выделяется память достаточная для передачи DMA Значение должно быть одним из следующих:

Значение	Описание
ADC_PORT_DMA_READ	Разрешение или запрещение чтения из устройства с использованием канала DMA.
ADC_PORT_DMA_WRITE	Разрешение или запрещение записи в устройство с использованием канала DMA

	m_nDMASize
Размер буфера для DMA передачи в 16 разрядных словах

	m_pInterruptLabel
Временно не поддерживается

	m_pDMABuffer     
Указатель на массив для передачи данных. Это поле после вызова содержит адрес массива для обмена данными. Перед вызовом значение указателя должно быть нулевым.
     

?	Структура параметров для низкоуровневого программирования прерываний вызванных различными событиями (в существующей версии поддерживается только платами LPT и PCI):

struct  ADCParametersPORT_INTERRUPT : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_PORT_INTERRUPT_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersPORT_INTERRUPT)
// ---------------------------
    unsigned    m_nIntOf;           
};

m_nIntOf
Значение, определяющее для каких прерываний нужно включить обработчик. Представляет собой битовую маску и может быть комбинацией из следующих значений:

Значение	Описание
ADC_PORT_INTERRUPT_DMA 	Разрешение генерации прерываний связанных с использованием канала DMA
ADC_PORT_INTERRUPT_ADC	Разрешение генерации прерываний от АЦП и других функциональных устройств платы

 
?	Структура параметров для задания параметров измерений для платы ЛА-и24:

struct ADCParametersSLOW : public ADCParametersBase
{
// --- Унаследованные поля ---
    int      m_nType;     // должен быть ADC_SLOW_TYPE
    int      m_nSizeOf;   // должен быть равен sizeof(ADCParametersSLOW)
// ---------------------------
    int      m_nStartOf;       // источник сигнала запуска преобразования
    
    int      m_nChannelMask;   // маска для активизации каналов
    // параметры на каждый канал
    float    m_fFreq[3];       // частота среза фильтра
    int      m_nCalibMode[3];  // режим калибровки
    int      m_nGain[3];       // коэффициент усиления
    int      m_nChan[3];       // выбор входа
    int      m_nPowerDown[3];  // выключение канала
    int      m_nIo[3];         // включение источника тока 100На
    int      m_nUnipolar[3];   // полярность

    ADCParametersSLOW();       // конструктор – автоматически устанавливает
                               // два первых параметра (m_nType и m_nSizeOf)
}
m_nStartOf
Этот параметр задаёт способ запуска преобразований и сигнала окончания преобразования. Возможные значения:

Значение	Описание
ADCPARAM_START_PROGRAMM	Запуск преобразований без разрешения прерываний, для получения результата преобразования надо проверять готовность данных при помощи метода Get(ADC_GET_READY, …)
ADCPARAM_START_TIMER	Запуск преобразований с разрешением прерываний


Остальные параметры полностью соответствуют одноимённым параметрам в инструкции к плате, где подробно описаны допустимые значения и их смысл.

Возвращаемое значение:
Если параметры измерений заданы успешно, то метод Init возвратит 1. Если произошли ошибки, то возможные коды следующие:

Значение	Описание
ADC_ERROR_NOTSUPPORTED	Функция не поддерживается
ADC_ERROR_NOTINITIALIZE	Драйвер не инициализирован (не указан базовый адрес)
ADC_ERROR_INVALIDPARAMETERS	Недопустимые значения параметров
ADC_ERROR_LOADXILINX	Не загружена программируемая логика

Описание:
Метод задаёт параметры измерения. Можно вызывать только после метода Setup, перед запуском преобразований. Обычно, выполняется относительно «долго», поэтому не рекомендуется использовать в цикле сбора одиночных значений.
Пример на C++:
. . .
ADCParametersDMA d;

d.m_nStartOf      = ADCPARAM_START_TIMER;
d.m_nIntOf        = ADCPARAM_INT_TC;

d.m_nDMABlockSize = DMA_BLOCK_SIZE;
d.m_nDMAMode      = 0;			// одиночная передача по каналу ДМА
d.m_fFreqStart    = 10000.0f;
d.m_nTimerStart   = ADCPARAM_TIMER0;
d.m_fFreqPack     = 0.0f;		// Сбор данных по одному каналу
d.m_nTimerPack     = ADCPARAM_TIMER1;
d.m_nFirstChannel  = 0;
d.m_nChannelNumber = 1;			 // Сбор данных по одному каналу
d.m_nGain          = 1;

if (pADC->Init(ADC_INIT_MODE_CHECK, &d, NULL) != 1)
{
cout << "Can't Init(INIT_MODE_CHECK)" << endl;
	getch();
	return;
}
if (pADC->Init(ADC_INIT_MODE_INIT, &d, NULL) != 1)
{
	cout << "Can't Init(INIT_MODE_INIT)" << endl;
	getch();
	return;
}
. . .

Метод Start
Использование:
Запуск преобразований.
Синтаксис:
int Start(void);
Параметры:
-
Возвращаемое значение:
Если преобразование(я) запущены удачно, метод возвращает 1. В случае ошибки возвращается 0 или код из подмножества общих кодов ошибок.
Описание:
Метод запускает преобразование. Параметры и режим преобразования указываются при вызове метода Init.
Пример на C++:
. . .
if ( !pADC->Start() ) return -1;	// Преобразование не запущено!
. . .
// Процедура сбора данных
. . .
pADC->Stop();
. . .	
Метод Stop
Использование:
Остановка преобразований.
Синтаксис:
void Stop(void);
Параметры:
-
Возвращаемое значение:
-
Описание:
Метод останавливает преобразование. Устройство LAXXX после его вызова не активно и соответствующие IRQ/DRQ запрещены.
Пример на C++:
Смотрите предыдущий пример.
Метод GetData
Использование:
Получение блока данных.
Синтаксис:
int GetData(int mode, char* pAdr, int size, int offset);
Параметры:
mode
Режим передачи данных. Может быть комбинацией из двух параметров. Первый определяет канал DMA, по которому производилась передача данных. Этот параметр используется только для плат, поддерживающих передачу данных по двум каналам DMA. Он может принимать следующие значения:

Значение	Описание
ADC_DATA_MODE_DATAFROMDMA	Читает данные из DMA 0 (допускает объединение по «ИЛИ» с флагами конверсии)
ADC_DATA_MODE_DATAFROMDMA0	Читает данные из DMA 0 (допускает объединение по «ИЛИ» с флагами конверсии)
ADC_DATA_MODE_DATAFROMDMA1	Читает данные из DMA 1 (допускает объединение по «ИЛИ» с флагами конверсии)
ADC_DATA_MODE_DATAASIS	Читает данные из плат с памятью «Как есть» без преобразования. Что и как считается, зависит от типа платы. Необходимо ознакомиться с документацией.
ADC_DATA_MODE_DATACH0 	Читает данные из канала 0 (допускает объединение по «ИЛИ» с флагами конверсии)
ADC_DATA_MODE_DATACH1	Читает данные из канала 1 (допускает объединение по «ИЛИ» с флагами конверсии)
ADC_DATA_MODE_DATABOTH	Читает данные из обоих каналов, 0,1,0,1… (допускает объединение по «ИЛИ» с флагами конверсии)
ADC_DATA_MODE_DATASWAP	Читает данные из обоих каналов, но располагает их в обратном порядке, 1,0,1,0… (допускает объединение по «ИЛИ» с флагами конверсии)


С помощью этих флагов можно задать преобразование данных в целочисленный формат, принятый в C, C++ или Pascal’е. Он может принимать следующие значения:

Значение	Описание
ADC_DATA_MODE_CONVERT2INT16	Конвертирует данные в 16-битный целочисленный формат, удаляя информацию о номере канала
ADC_DATA_MODE_CONVERT2INT16M	Конвертирует данные в 16-битный целочисленный формат, удаляя информацию о номере канала и нормируя данные в диапазоне -32768:32767
ADC_DATA_MODE_CONVERT2INT32	Конвертирует данные в 32-битный целочисленный формат, удаляя информацию о номере канала
ADC_DATA_MODE_CONVERT2INT32M	Конвертирует данные в 32-битный целочисленный формат, удаляя информацию о номере канала и нормируя данные в диапазоне -2147483648: 2147483647

pAdr
Адрес массива, куда будут помещены данные.
size 
Количество слов данных, которые будут считаны из буфера DMA. В  зависимости от  используемого канала DMA слово может быть 8 или 16 разрядным. Во всех существующих   платах слово имеет длину 16  разрядов.
offset
Смещение от начала буфера в словах. Позволяет считать данные из произвольного места в буфере DMA или из локального буфера платы.
Возвращаемое значение:
В случае успешного завершения метод возвращает количество считанных слов данных. Если произошла ошибка, то код ошибки:

Значение	Описание
ADC_ERROR_NOTSUPPORTED	функция не поддерживается
ADC_ERROR_NOTINITIALIZE	драйвер не инициализирован (не указан базовый адрес)
ADC_ERROR_INVALIDPARAMETERS	недопустимые значения параметров

Описание:
Метод позволяет считать порцию данных из буфера DMA в буфер пользователя. Можно преобразовать  данные для более удобного их использования.
Для плат с внутренним буфером, которые работают без использования DMA, функция GetData читает данные непосредственно из буфера платы, если указан флаг ADC_DATA_MODE_DATAASIS, при этом параметр offset  не имеет смысла и не используется.
Пример на C++:
. . .
IADCDevice* pADC;
short       buf[4096];
. . .
// Инициализация объекта IADCDevice
. . .
pADC->ClearInterrupt();
pADC->Start();
while (WaitForSingleObject(hEvent, 3000) == WAIT_OBJECT_0)
{
	pADC->GetData(ADC_DATA_MODE_CONVERT2INT16, buf, sizeof(buf), 0);
	. . .
	// Обработка данных
	. . .
	pADC->ClearInterrupt();
pADC->Start();
}
pADC->Stop();
. . .
pADC->Release();

Метод PortIO
Использование:
Получение блока данных.
Синтаксис:
int PortIO(int mode, char* pAdr, int size);
Параметры:
mode
Режим передачи данных. Может принимать одно из следующих значений:

Значение	Описание
ADC_PORTIO_OUTB	Вывод байтов
ADC_PORTIO_INB	Ввод байтов
ADC_PORTIO_OUTW	Вывод 16 разрядных слов
ADC_PORTIO_INW	Ввод 16 разрядных слов
ADC_PORTIO_OUTD	Вывод 32 разрядных слов
ADC_PORTIO_IND	Ввод 32 разрядных слов
ADC_PORTIO_OUTB_PORT2	Вывод байтов во второй цифровой порт
ADC_PORTIO_INB_PORT2	Ввод байтов из второго цифрового порта

pAdr
Адрес массива, куда будут помещены или откуда будут считаны данные.
size 
Количество слов данных.
Возвращаемое значение:
В случае успешного завершения метод возвращает 1. Если произошла ошибка –  код ошибки:

Значение	Описание
ADC_ERROR_NOTSUPPORTED	функция не поддерживается
ADC_ERROR_NOTINITIALIZE	драйвер не инициализирован (не указан базовый адрес)
ADC_ERROR_INVALIDPARAMETERS	недопустимые значения параметров

Описание:
Метод читает size значений из порта цифрового ввода-вывода в буфер, на который указывает pAdr. Метод пишет size значений в порт цифрового ввода-вывода из буфера, на который указывает pAdr.
Пример:
. . .

Метод Get
Использование:
Получение сведений о плате и драйвере.
Синтаксис:
int Get(int mode, void* value);
Параметры:
mode
Определяет, что именно надо узнать о плате или драйвере. В зависимости от значения этого параметра по-разному интерпретируется тип указателя value, а как именно указано в поле “Тип” таблицы. Возможны следующие значения:

Значение	Тип	Описание
ADC_GET_READY	int32	1 при готовности данных  в случае одиночного преобразования
ADC_GET_DATA	int32	Результат преобразований в случае одиночного преобразования
ADC_GET_DMACOUNTER	int32	Значение счетчика DMA 0
ADC_GET_DMACOUNTER0	int32	Значение счетчика DMA 0
ADC_GET_DMACOUNTER1	int32	Значение счетчика DMA 1
ADC_GET_INTERRUPT_READY	int32	Значение бита готовности
ADC_GET_INTERRUPT_TC	int32	Значение бита сигнала TC
ADC_GET_INTERRUPT_EXT	int32	Значение бита внешнего прерывания
ADC_GET_ADCMODE	int32	Значение бита режима ADC
ADC_GET_STATUS	int32	Значение статусного регистра "как есть"
ADC_GET_COMP	int32	Состояние компаратора: сработал он (> 0) или нет ( = 0)
ADC_GET_BASE	int32	Базовый адрес порта
ADC_GET_IRQ	int32	Номер используемого прерывания
ADC_GET_DRQ	int32	Номер используемого канала DMA 0
ADC_GET_DRQ0	int32	Номер используемого канала DMA 0
ADC_GET_DRQ1	int32	Номер используемого канала DMA 1
ADC_GET_CLOCK	float32	Частота кварцевого генератора
ADC_GET_NAME	char**	Имя драйвера
ADC_CALIBRATE	-	Производит автоматическую калибровку для тех плат, где это возможно
ADC_GET_CAPABILITY	int32	Функции, поддерживаемые платой, в виде комбинации значений, которые описаны в подразделе «Возвращаемые значения»
ADC_GET_CAPABILITY_EX	int32[4]	Аналогично предыдущему параметру, только возвращается четыре 32-битных значения, содержащих наборы флагов, показывающих все функции устройства
ADC_GET_BASELIST	int32*	Адрес таблицы возможных значений        базового адреса
ADC_GET_IRQSLIT	int32*	Адрес таблицы возможных значений IRQ
ADC_GET_DRQLIST	int32*	Адрес таблицы возможных значений DRQ
ADC_GET_DEFAULTBASEINDEX	int32	Индекс в таблице базовых адресов для адреса порта по умолчанию
ADC_GET_DEFAULTIRQINDEX	int32	Индекс в таблице IRQ для прерывания по умолчанию
ADC_GET_DEFAULTDRQINDEX	int32	Индекс в таблице DRQ для канала ПДП по умолчанию
ADC_GET_MINFREQ	int32	Минимально возможная частота, генерируемая таймером
ADC_GET_MAXFREQ	int32	Максимально возможная частота,      генерируемая таймером
ADC_GET_MINAMP	int32	Минимальное значение амплитуды
ADC_GET_MAXAMP	int32	Максимальное значение амплитуды
ADC_GET_FREQLIST		*float32	Таблица допустимых частот квантования
ADC_GET_DATASIZE	int32	Размер в байтах, необходимый для записи одного значения
ADC_GET_DATABITS	int32	Разрядность АЦП преобразования
ADC_GET_DATAMASK	int32	Маска для выделения кода АЦП
ADC_GET_CHANNELMASK	int32	Маска для выделения номера канала
ADC_GET_IRQMASK	int32	Младшие 16 битов позволяют определить доступность линий IRQ (0 – не доступна, 1 – доступна)
ADC_GET_DRQMASK	int32	Младшие  8 битов позволяют определить доступность каналов DRQ (0 – не доступен, 1 – доступен)
ADC_GET_XC_STAT	int32	Статус загрузки ПЛИС
ADC_GET_NCHANNEL	int32	Количество аналоговых каналов
ADC_GET_SIZELIST	*int32	Адрес таблицы допустимых размеров блоков собираемых данных
ADC_GET_SIZELIST_SIZE	int32	Число элементов таблицы допустимых размеров блоков данных
ADC_GET_FREQLIST_SIZE	int32	Число элементов таблицы допустимых частот квантования
ADC_GET_BASELIST_SIZE	int32	Размер таблицы возможных базовых адресов
ADC_GET_IRQLIST_SIZE	int32	Размер таблицы возможных номеров прерываний
ADC_GET_DRQLIST_SIZE	int32	Размер таблицы возможных номеров каналов ПДП
ADC_GET_GAINLIST	*int32	Адрес таблицы допустимых коэффициентов усиления
ADC_GET_GAINLIST_SIZE	int32	Размер таблицы допустимых коэффициентов усиления
ADC_GET_DATA_LSHIFT	int32	Число, на которое надо сдвинуть результат влево, чтобы выделить данные
ADC_GET_DATA_RSHIFT	int32	Число, на которое надо сдвинуть результат вправо, чтобы выделить данные
ADC_SET_ADCMODE_END*	-	Переключение мультиплексора каналов по концу преобразования
ADC_SET_ADCMODE_START*	-	Переключение мультиплексора каналов перед началом преобразования
ADC_SET_ADCMODE_DEBUG	-	Зарезервировано для внутреннего использования
ADC_SET_ADCMODE_RELEASE	-	Зарезервировано для внутреннего использования
ADC_GET_VERSION	int32	Текущая версия драйвера
ADC_GET_MEMORYSIZE	int32	Размер памяти, установленной на плате
ADC_GET_PREHISTORY_SIZE	int32	Размер предыстории
ADC_ZERO_CALIBRATE	float32	Вычисляет смещение относительно нуля (работает только для плат ЛА-7 и ЛА-14)
ADC_GET_DATA_EXT*	int32	Получение результата одного преобразования при внешних стартах без использования ПДП
ADC_GET_DRQ_MODE*	int32	Возвращает текущий режим работы ПДП
ADC_GET_RANGE_BIPOLAR	float32	Допустимый диапазон входного напряжения в вольтах в двухполюсном режиме
ADC_GET_RANGE_UNIPOLAR	float32	Допустимый диапазон входного напряжения в вольтах в однополюсном режиме
ADC_SET_DRQ_MODE_SINGLE*	-	Устанавливает "Single" режим передачи по ПДП (см. описание программирование контроллера ПДП компьютера)
ADC_SET_DRQ_MODE_DEMAND*	-	Устанавливает "Demand" режим передачи по ПДП (см. описание программирования контроллера ПДП компьютера)
* - только для драйвера LAVP.

Возвращаемое значение:
Возвращает 0 если нельзя получить интересующее свойство или 1, если значение скопировано в буфер value. Если в параметре mode была указана константа ADC_GET_CAPABILITY, то в буфере value будет комбинация из следующих возможных значений:

Значение	Описание
ADC_CAPS_DMA	Поддерживается 1 канал DMA
ADC_CAPS_DMA0	поддерживается 1 канал DMA
ADC_CAPS_DMA1	поддерживается 2 канала DMA
ADC_CAPS_DMAHALF	Поддерживается прерывание по заполнению  половины буфера DMA
ADC_CAPS_DMASWITCH	Поддерживается 2 канала DMA с автоматическим переключением по сигналу TC
ADC_CAPS_INTERRUPT	Поддерживается 1 канал IRQ
ADC_CAPS_INTERRUPT0	Поддерживается 1 канал IRQ
ADC_CAPS_INTERRUPT1	Поддерживается 2 канала IRQ
ADC_CAPS_INTERRUPT_READY	Поддерживается прерывание по  окончанию преобразования
ADC_CAPS_INTERRUPT_TC	Поддерживается прерывание по окончанию  цикла DMA
ADC_CAPS_INTERRUPT_EXT	Поддерживается прерывание от внешнего  источника
ADC_CAPS_GENERATOR	На плате есть генератор частоты для плавной настройки частоты дискретизации
ADC_CAPS_TIMER3	На плате есть 3х канальный таймер-счетчик
ADC_CAPS_TIMER8254	На плате установлен 3х канальный таймер-счетчик intel 8254
ADC_CAPS_EXTSTART	На плате есть возможность внешнего запуска преобразований
ADC_CAPS_MEMORY	На плате установлена локальная память для сохранения результатов измерений
ADC_CAPS_MEMORYPERCHANNEL	Произвольный размер блока для сохранения измерений для каждого канала
ADC_CAPS_FREQLIST	Устройство имеет таблицу фиксированных частот квантования
ADC_CAPS_SIZELIST	Устройство имеет таблицу фиксированных размеров блоков собираемых за одно измерение данных
ADC_CAPS_DIGITAL_IN	Есть цифровой порт для ввода 8 разрядов
ADC_CAPS_DIGITAL_OUT	Есть цифровой порт для вывода 8  разрядов
ADC_CAPS_DIGITAL_16	Есть цифровой порт 16 разрядов
ADC_CAPS_DIGITAL_32	Есть цифровой порт 32 разряда
ADC_CAPS_GAINSLIST	Выбор коэффициента усиления из таблицы допустимых величин
ADC_CAPS_PREHISTORY	Поддерживается запись предыстории измерений
ADC_CAPS_GAINSPERCHANNEL	Поддерживается произвольный коэффициент  усиления для каждого канала
ADC_CAPS_GAINSFLOAT	Поддерживается произвольный коэффициент  усиления
ADC_CAPS_SYNCHROLEVEL	Поддерживается синхронизация по уровню
ADC_CAPS_SYNCHROLOW	Поддерживается синхронизация по возрастающему уровню
ADC_CAPS_SYNCHROHIGH	Поддерживается синхронизация по ниспадающему уровню
ADC_CAPS_SYNCHRO2	На плате установлено 2 компаратора
ADC_CAPS_CHANNELDIR_GROWTH	Данные передаются по возрастанию номера канала
ADC_CAPS_CHANNELDIR_DECREASE	Данные передаются по уменьшению номера канала
ADC_CAPS_CHANNELDIR_FREE	Данные передаются в произвольном порядке 
ADC_CAPS_CALIBRATE	Поддерживается режим авто калибровки

Описание:
Очень многофункциональный метод. Позволяет получить сведения о плате (поддерживаемые базовые адреса порта, прерывания, каналы DMA, сведения о поддерживаемых функциях и т.д.), текущей конфигурации драйвера, получать состояние платы и результаты преобразований в режиме одиночного сбора.
Пример на C++:
. . .
IADCDevice* pADC;
. . .
// Загрузка драйвера
. . .
int port, index, *ptr;
pADC->Get(ADC_GET_BASELIST, ptr);
pADC->Get(ADC_GET_DEFAULTBASEINDEX, &index);
port = ptr[index];
. . .
int caps;
pADC->Get(ADC_GET_CAPABILITY, &caps);
if ( (caps & ADC_CAPS_ INTERRUPT) != 0 && (caps & ADC_CAPS_DMA) != 0 )
{
// процедура сбора данных по DMA
}
. . .
Метод ClearInterrupt
Использование:
Разрешение следующего прерывания.
Синтаксис:
void ClearInterrupt();
Параметры:
-
Возвращаемое значение:
-
Описание:
Метод должен вызываться после обработки прерывания для того, чтобы разрешить возникновение следующего прерывания. Данный метод разрешает прерывания на плате, и раз маскирует используемые прерывание(я) и канал(ы) DMA.
Пример на C++:
. . .
IADCDevice* pADC;
. . .
// Инициализация объекта IADCDevice
. . .
pADC->ClearInterrupt();
pADC->Start();
while (WaitForSingleObject(hEvent, 3000) == WAIT_OBJECT_0)
{
	pADC->GetData(ADC_DATA_MODE_CONVERT2INT16, buf, sizeof(buf));
	. . .
	// Обработка данных
	. . .
	pADC->ClearInterrupt();
	pADC->Start();
}
pADC->Stop();
. . .
pADC->Release();

3.6. Пример использования
Ниже следует пример использования поставляемых средств разработки приложений для C++. Этот пример может быть скомпилирован, например, в среде Microsoft Developer Studio (TM) или Borland C++ Builder как консольное приложение Win32. Данная программа производит сбор блоков данных по DMA в режиме одиночной передачи и запись их на диск, пока не будет нажата клавиша.

#include <conio.h>
#include <fstream.h>
#include <string.h>
#pragma hdrstop
#include “REGKEY/VT_Drivers.ri”
#include “DllClient.h”
#include “IFactory.h”
#include “IADCDevice.h”
#include “ADC_Const.h”

int main() 
{
int port, irq, drq, index, *ptr;
HANDLE hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
DllClient LAxClient;
IFactory* LAxFactory = 0;

char drvname[40];
LAxClient.GetRegName(drvname, 20, 0, CompanyNameDRV, ProductNameDRV, 
                     VersionNameDRV);

if( (LAxFactory = (IFactory*)LAxClient.LoadRegistered(
CompanyNameDRV, ProductNameDRV, VersionNameDRV, drvname,
      "StaticFactory")) == 0) return -1;

IADCDevice* pADC = (IADCDevice*)LAxFactory->Create("IADCDevice", 0);
if(pADC == 0) return -1;

int caps;
pADC->Get(ADC_GET_CAPABILITY, &caps);
if ( (caps & ADC_CAPS_INTERRUPT) == 0 || 
     (caps & ADC_CAPS_DMA) == 0 ) return –1;

pADC->Get(ADC_GET_BASELIST, &ptr);
pADC->Get(ADC_GET_DEFAULTBASEINDEX, &index);
port = ptr[index];

pADC->Get(ADC_GET_IRQLIST, &ptr);
pADC->Get(ADC_GET_DEFAULTIRQINDEX, &index);
irq = ptr[index];

pADC->Get(ADC_GET_DRQLIST, &ptr);
pADC->Get(ADC_GET_DEFAULTDRQINDEX, &index);
drq = ptr[index];

ADCParametersDMA d;
d.m_nStartOf = ADCPARAM_START_TIMER;
d.m_nIntOf = ADCPARAM_INT_TC;
d.m_nDMABlockSize = 100;
d.m_nDMAMode = 0;				
d.m_fFreqStart = 10000.0f;
d.m_nTimerStart = ADCPARAM_TIMER0;
d.m_fFreqPack = 0.0f;			
d.m_nTimerPack = 0;	 
d.m_nFirstChannel = 0;
d.m_nChannelNumber = 1;			
d.m_nGain = 1;

if (pADC->Setup(port, drq, irq, hEvent) <= 0) return –1;

if (pADC->Init(ADC_INIT_MODE_INIT, &d, NULL) <= 0) return –1;

strcat(drvname, “.dat”);
fstream datf(drvname, ios::app | ios::trunc, filebuf::sh_none);

int sz;
short buf[100];
pADC->ClearInterrupt();
pADC->Start();

while(WaitForSingleObject(hEvent, 3000) == WAIT_OBJECT_0) 
{
	sz = pADC->GetData(ADC_DATA_MODE_DATAFROMDMA, buf, 100, 0);
	for (int i = 0; i < sz; (datf << buf[i] << ‘,’), i++);
Sleep(100);
	if ( kbhit() ) break;
	pADC->ClearInterrupt();
	pADC->Start();
}

pADC->Stop();
pADC->Release();
datf.close();

return 0;
}
4. Описание интерфейса библиотеки LAUtil.DLL(LAUtil1.DLL) для программирования на C++.
4.1. Назначение библиотеки LAUtil.dll(LAUtil1.dll)
LAUtil.DLL – это библиотека динамической компоновки, позволяющая организовывать непрерывный сбор данных и их обработку в реальном или квази-реальном времени при помощи плат АЦП с контроллером ПДП. Для управления платой АЦП библиотека LAUtil использует драйвер этой платы. Поэтому для лучшего понимания описания интерфейса этой библиотеки рекомендуется сначала прочитать предыдущие разделы. Также желательно знать, как работает контроллер ПДП компьютера (типа IBM PC). На момент написания этого документа возможность непрерывного сбора данных поддерживали следующие платы АЦП: ЛА-1.5, ЛА-2, ЛА-3, ЛА-2М2(3), ЛА-4, ЛА-7, ЛА-8, ЛА-12, ЛА-14, ЛА-20, ЛА-ADSP, ЛА-2МXPCI.
Для LAUtil.dll сбор данных осуществляется блоками, размер которых может изменяться от 2 16-битных кило слов до 32 кило слов с шагом в 2 кило слова. Для LAUtil1.dll размер блоков для передачи кратен одному 16 битному слову. Блоки помещаются в циклическую очередь, после чего данные могут быть обработаны или записаны на диск для использования в дальнейшем. Размер циклической очереди определяется размером свободной памяти. При исчерпании свободной памяти для хранения только что собранных данных будут использоваться самые «старые» блоки в очереди.
Библиотека LAUtil.dll работает с меньшей загрузкой центрального процессора, чем LAUtil1.dll. 

4.2. Заголовочный файл класса интерфейса библиотеки LAUtil.dll
Интерфейс, предоставляемый библиотекой LAUtil.dll описан в файле "IADCUtility.h":

struct  IADCUtility
{
    virtual unsigned __stdcall  AddRef();
    virtual unsigned __stdcall  Release();

    virtual int      __stdcall  Setup(char* name, int baseAdr,
                                      int DRQ, int blockSize2KW);
    virtual int      __stdcall  Start(ADCParametersBase* par, 
                                      int priority = 0);
    virtual int      __stdcall  GetBuffer(void*& adr, unsigned& mask);
    virtual int      __stdcall  FreeBuffer();
    virtual int      __stdcall  Get(int mode, void* value);
    virtual int      __stdcall  Stop();
};


4.3 Описание класса интерфейса библиотеки LAUtil.dll
Метод AddRef
Использование:
Увеличение счетчика ссылок на объект IADCUtility при передаче указателя на него в другой модуль.
Синтаксис:
unsigned AddRef(void);
Параметры:
-
Возвращаемое значение:
Текущее значение счетчика ссылок на объект.
Описание:
Метод увеличивает счётчик ссылок на объект на 1.
Пример на C++:
. . .
IADCUtility* pADCUtility;
. . .
pADCUtility->AddRef();
SomeWierdProc(pADCUtility);
. . .
pADCUtility->Release();
}

SomeWierdProc(IADCUtility* myADCUtility)
{
	. . .
	// Использование указателя myADCUtility
	myADCUtility->Release();
}

Метод Release
Использование:
Уменьшение счетчика ссылок на объект IADCUtility при завершении его использования.
Синтаксис:
unsigned Release(void);
Параметры:
-
Возвращаемое значение:
Номер копии объекта.
Описание:
Метод уменьшает счетчик ссылок на объект на 1, при достижении счётчиком  значения 0 объект уничтожается.
Пример на C++:
Смотрите пример к предыдущему методу.
Метод Setup
Использование:
Настройка параметров платы.
Синтаксис:
 int Setup(
char* name,        // имя драйвера платы
int baseAdr,       // базовый адрес платы
int DRQ,           // номер канала ПДП
int blockSize2KW); // размер блока в страницах по 2 кило слова
Параметры:
name
Имя драйвера платы, с помощью которой Вы собираетесь организовывать непрерывный сбор данных. Таблицу с именами драйверов плат смотрите ниже, в конце текста.
BaseAdr
Базовый адрес платы в пространстве ввода/вывода. Для плат Plug’n’Play (то есть PCI) и внешних устройств, подключаемых, например, к параллельному порту компьютера, в качестве базового адреса передаётся номер платы (устройства). Для плат с интерфейсом PCI номер определяется следующим образом: плата №1 находится в самом верхнем слоте PCI  (ближайшем к слоту AGP), следующая такая же плата будет иметь №2 и так далее. Для внешних устройств на параллельный порт в качестве в параметре BaseAdr следует передавать номер порта.
DRQ
Номер канала DMA.
blockSize2KW
Размер блока данных, выраженный в страницах по 2 кило слова (4 килобайта). Минимально допустимое значение этого параметра 1, а максимально допустимое значение 32. Для библиотеки LAUtil1.dll это значение равно размеру блока в 16-ти разрядных словах.
Возвращаемое значение:
Если параметры платы настроены успешно, метод возвращает 1.
В случае возникновения ошибки в библиотеке возвращается её код. Возможные коды ошибок:

Значение	Описание
0	неправильные значения одного или нескольких параметров
-100	не удалось загрузить драйвер с указанным именем, или он отсутствует
-200	не удалось получить у драйвера интерфейс (см. описание классов IADCDevice и DllClient), или неправильный драйвер
-300	библиотека не может использовать указанный драйвер или плата не поддерживает возможность организации непрерывного сбора данных
В случае возникновения ошибки в драйвере возвращается код ошибки драйвера (см. описание метода Setup класса IADCDevice).

Описание:
Этот метод загружает драйвер, имеющий имя name, далее вызывается метод Setup драйвера (см. описание класса IADCDevice) с указанным базовым адресом и номером канала ПДП, прерывания не используются. Затем распределяется память под первый блок для хранения собираемых данных.

Пример на C++:
...
DllClient UtilClient;
IADCUtility* pADCU = UtilClient.LoadLibrary(“LAUtil”, _T("IADCUtility"));
...
// Задаём параметры платы и сбора данных:
int error = pADCU->Setup(“LAVP”, 0x320, 7, 1);
if(error <= 0)
{
// Обработка ошибки
}
...

Метод Start
Использование:
Запуск непрерывного сбора данных.
Синтаксис:
int Start(
ADCParametersBase* par, // параметры измерения
int priority = 0);      // приоритет
Параметры:
par
Задаёт параметры измерения, представляет собой указатель либо на структуру ADCParametersDMA, либо на структуру ADCParametersDMA1 (см. описание метода Init класса IADCDevice). При этом значения полей m_nIntOf, m_nDMABlockSize, m_nDMAMode игнорируются, так как задаются изнутри.
priority
Определяет приоритет потока (thread), осуществляющего непосредственно сам процесс сбора данных. Значение по умолчанию, или 0, задаёт нормальный приоритет (THREAD_PRIORITY_NORMAL) потока, а ненулевое значение – самый высокий (THREAD_PRIORITY_TIME_CRITICAL).
Возвращаемое значение:
В случае успешного запуска процесса непрерывного сбора данных метод Start возвратит 1, иначе возможны следующие значения:
Значение	Описание
0	неправильные значения параметров
-99	параметр par не является указателем ни на структуру ADCParametersDMA, ни на ADCParametersDMA1
-200	не удалось создать поток (thread) для сбора данных
В случае возникновения ошибки в драйвере возвращается код ошибки драйвера (см. описание возвращаемых значений методов Setup, Init и Start класса IADCDevice).
Описание:
Метод Start вызывает метод Init драйвера платы (см. описание класса IADCDevice), передавая ему структуру, на которую указывает par, при этом заполняет поля m_nIntOf, m_nDMABlockSize и m_nDMAMode «правильными» значениями. Затем создаётся поток, в котором параллельно с «родительским» и осуществляется процедура непрерывного сбора данных.
Пример на C++:
...
IADCUtility* pADCU;
...
// Инициализируем структуру параметров измерения
ADCParametersDMA p;
p.m_nStartOf =       ADCPARAM_START_TIMER;  // Запуск АЦП от таймера
p.m_fFreqStart =     200000; // Частота дискретизации, Гц
p.m_nTimerStart =    0;      // Номер канала таймера для запусков АЦП
p.m_fFreqPack =      0;      // Частота кадров (режим отключен)
p.m_nTimerPack =     1;      // Номер канала таймера для формирования кадров
p.m_nFirstChannel =  0;      // Первый канал в режиме авто сканирования
p.m_nChannelNumber = 16;     // Сколько всего каналов сканировать
p.m_nGain =          0;      // Коэффициент усиления
// Запуск асинхронного процесса сбора данных        
as = pADCU->Start(&p, 0);
if(as <= 0)
{
	// обработка ошибки
	... 
}
// Собственно получение данных
for(int i=0; i<MAIN_SIZE;)
{
void* adr; unsigned mask;
      DWORD size_write;
      if(pADCU->GetBuffer(adr, mask) > 0)
      {
		// обработка данных
		...
      }
// Освобождаем буфер
      pADCU->FreeBuffer();
}
// Останов преобразования
pADCU->Stop();
...
Метод GetBuffer
Использование:
Получение очередного блока данных.
Синтаксис:
int GetBuffer(void*& adr, unsigned& mask);
Параметры:
adr
Ссылка на указатель, в который будет помещён адрес очередного блока данных.
mask
Состояние блока: помещены ли данные с наложением.
Возвращаемое значение:
Если функция вернула ненулевое значение, то параметры adr и mask заполняются правильными значениями. Если очередной блок еще не собран, возвращается 0.
Описание:
В переменную adr помещается указатель на блок только что собранных данных размером, задаваемом в методе Setup. В переменную mask помещается 32-битное слово состояния данных в блоке: каждый бит соответствует странице размером 2КС, его нулевое значение говорит о том, что эта страница «хорошая»; установленный бит означает, что страница «плохая», то есть, записана с наложением данных, что может случиться, если процедура непрерывного сбора данных не успела вовремя скопировать соответствующую страницу из буфера DMA. Для библиотеки LAUtil1.dll можно судить только о количестве ошибок в блоке. Проще говоря, при правильной работе значение должно быть нулевым.
Пример на C++:
Смотрите предыдущий пример.
Метод FreeBuffer
Использование:
Освобождение обработанного блока данных.
Синтаксис:
int FreeBuffer();
Параметры:
-
Возвращаемое значение:
Ненулевое значение означает успешное выполнение метода.
Описание:
Освобождается блок данных из циклического списка, к которому происходило обращение при последнем вызове метода GetBuffer.
Пример на C++:
Смотрите пример к методу Start.
Метод Get
Использование:
Получение различных сведений.
Синтаксис:
int Get(int mode, void* value);
Параметры:
mode
Константа, определяющая какие сведения надо получить или выполнить действия.
value
Адрес переменной, куда будет помещено запрашиваемое значение.
Возвращаемое значение:
Ненулевое значение означает успешное выполнение.
Описание:
Используется для получения вспомогательной информации о функционировании утилиты, а также для задания дополнительных параметров. В зависимости от значения параметра mode возможны следующие интерпретации параметра value:
Значение mode	Тип value	Значение, помещаемое в value
ADCUTILITY_VERSION	int32	Версия библиотеки LAUtil.dll
ADCUTILITY_STATUS_RUN	int32	1, если идёт сбор данных, иначе 0
ADCUTILITY_STATUS_ERRORS	int32	Код последней ошибки
ADCUTILITY_STATUS_BLOCKS	int32	Количество используемых в циклической очереди блоков
ADCUTILITY_BLOCKSIZE	int32	Размер блока в страницах по 2К Слова (4КБайта), равно значению blockSize2KW, переданному во время вызова метода Setup
ADCUTILITY_GOODBLOCKSIZE	int32	«Хороший» размер блока = 32 страницы по 2КС
ADCUTILITY_MINBLOCKSIZE	int32	Минимально возможный размер блока в страницах по 2КС (4Кб), на данный момент всегда 1
ADCUTILITY_MAXBLOCKSIZE	int32	Максимально возможный размер блока в страницах по 2КС (4Кб), на данный момент всегда 32
ADCUTILITY_STATUS_FULLBLOCKS	int32	Количество собранных блоков
ADCUTILITY_GET_IADCDEVICE	IADCDevice*	Указатель на класс интерфейса драйвера платы АЦП, который используется для управления сбором данных

Также при помощи следующих значений параметра mode возможно задать такие опции процедуре сбора данных (при этом value не используется, можно вместо реального адреса передавать 0):
Значение	Описание
ADCUTILITY_SET_NOCONVERT	При получении данных из буфера DMA, над ними не производится ни каких преобразований, данные хранятся в циклической очереди как есть. Для получения данных из буфера DMA используется метод GetData драйвера платы (см. описание класса IADCDevice), значение параметра mode будет равно 0
ADCUTILITY_SET_CONVERT2INT16	При получении данных из буфера DMA из них удаляется номер канала; значение параметра mode будет равно ADC_DATA_MODE_CONVERT2INT16 при вызове функции GetData драйвера
ADCUTILITY_SET_CONVERT2INT16M	При получении данных из буфера DMA из них удаляется номер канала, данные нормируются в диапазоне –32768..+32767; значение параметра mode будет равно ADC_DATA_MODE_CONVERT2INT16M при вызове функции GetData драйвера

Пример на C++:
...
IADCUility pADCU;
...
int verno;
pADCU->Get(ADCUTILITY_VERSION, &verno);
...
IADCDevice *pADC;
pADCU->Get(ADCUTILITY_GET_IADCDEVICE, &pADC);
...
Метод Stop
Использование:
Останов процедуры непрерывного сбора данных.
Синтаксис:
int Stop();
Параметры:
-
Возвращаемое значение:
Ненулевое значение означает успешное выполнение.
Описание:
Завершается работа порождённого потока (thread-а), в котором осуществлялся сбор. Вызывается метод Stop драйвера платы.
Пример на C++:
Смотрите пример к методу старт.
5. Описание интерфейса UNIDRIVER.DLL для программирования на C.
5.1. Назначение библиотеки Unidriver.dll
UNIDRIVER.DLL – это динамическая библиотека, делающая возможным использование драйверов с интерфейсом "IADCDevice" и утилиты непрерывного сбора данных LAUtil.dll в программах на языке C и BASIC или других, то есть в не объектно-ориентированных средах программирования или в таких средах программирования, где трудно или невозможно использовать объекты (классы) в стиле C++. Исходные тексты этой библиотеки находятся в каталоге “..\Samples\UniDriver” (“C:\Program Files\Vt\Samples\UniDriver” при использовании путей по умолчанию при инсталляции LASDK). Для лучшего понимания описанных далее функций надо ознакомиться с предыдущими разделами.

5.2. Описание экспортируемых функций
Функция UniDriverGetName
Использование:
Получение имени драйвера.
Синтаксис:
  char* UniDriverGetName(char* data, int size, int index);
Параметры:
data
Адрес строки (массива символов), куда будет помещено имя драйвера. 
size
Размер массива символов для имени драйвера.
index
Порядковый номер драйвера в подразделе реестра.
Возвращаемое значение:
ASCIIZ-строка – название драйвера с порядковым номером index или NULL, если драйвера с таким порядковым номером нет.
Описание:
Читает из системного реестра информацию о драйверах, которые были зарегистрированы ранее. Эта функция «знает» подраздел, где находится информация о драйверах и по параметру index возвращает строку-имя драйвера.
Пример:
. . .
char str[10][20];
for(int n=0; n<10; ++n)
    if(UniDriverGetName(str[n], 20, n) == 0) break;
. . .

Функция UniDriverCreate
Использование:
Загрузка драйвера и создание объекта класса IADCDevice.
Синтаксис:
 	  unsigned UniDriverCreate(char* name);
Параметры:
name
Строка-имя драйвера, который будет использоваться для работы с платой.
Возвращаемое значение:
Возвращаемое значение есть не что иное, как указатель на объект. Его нужно  использовать для обращения ко всем остальным функциям в качестве первого параметра. Если не удаётся загрузить драйвер и получить интерфейс, то функция возвращает 0.
Описание:
Загружает в память драйвер с именем "name" и создает экземпляр интерфейса "IADCDevice". В случае успешного вызова этой функции, драйвер готов к работе и можно пользоваться функциями интерфейса.
Пример:
-
Функция UniDriverClose
Использование:
Уничтожение интерфейса.
Синтаксис:
  void UniDriverClose(unsigned d);
Параметры:
d
Указатель на объект, полученный при помощи функции UniDriverCreate.
Возвращаемое значение:
-
Описание:
Уничтожает экземпляр интерфейса "IADCDevice".
Пример:
-
Функции интерфейса драйвера
Использование:
Работа с платой.
Синтаксис:
int   UniDriverSetup(unsigned d, int baseAdr, int DRQ, int IRQ);  
int   UniDriverTest(unsigned d);
int   UniDriverInit(unsigned d, int mode, struct ADCParametersDMA* par);
int   UniDriverStart(unsigned d);
void  UniDriverStop(unsigned d);
void  UniDriverClearInterrupt(unsigned d);
int   UniDriverGetData(unsigned d, int mode, char* adr, int size, int offset);
int   UniDriverGet(unsigned d, int mode, void* par);
int   UniDriverPortIO(unsigned d, int mode, char* pAdr, int size);
Параметры:
d
Указатель на объект, полученный при помощи функции UniDriverCreate.
Описание остальных параметров смотрите в описаниях одноимённых методов в разделе 4 «Описание класса интерфейса драйвера».
Возвращаемое значение:
Описание возвращаемых значений смотрите в описаниях одноимённых методов в разделе 4 «Описание класса интерфейса драйвера».
Описание:
Все эти функции делают то же самое, что и одноименные функции из раздела «Описание класса интерфейса драйвера».
Если в функции UniDriverSetup указать IRQ > 0, то создается объект реакции на аппаратное прерывание. В дальнейшем можно использовать функцию ожидания для синхронизации хода выполнения Вашей программы с аппаратными прерываниями (см. далее).
Пример:
-
Функция UniDriverWaitEvent
Использование:
Ожидание аппаратного прерывания.
Синтаксис:
 int UniDriverWaitEvent(unsigned d, unsigned timeout); 
Параметры:
d
Указатель на объект, полученный при помощи функции UniDriverCreate.
timeout
Максимальное время ожидания прерывания в миллисекундах.
Возвращаемое значение:
Если прерывание случилось, то функция возвращает 1, если нет, то 0.
Описание:
Функция ожидает аппаратное прерывание.
Пример:
-
Функции интерфейса библиотеки непрерывного сбора.
Использование:
Организация непрерывного сбора данных для плат с контроллером ПДП.
Синтаксис:
int UtilitySetup(unsigned d, char* name, int baseAdr, int DRQ, int size2K);
int UtilityStart(unsigned d, struct UADCParametersDMA* par, int priority);
int UtilityStop(unsigned d);
int UtilityGetBuffer(unsigned d, void** adr, unsigned* mask);
int UtilityFreeBuffer(unsigned d);
int UtilityGet(unsigned d, int mode, void* par);
Параметры:
d
Указатель на объект, полученный при помощи функции UtilityCreate.
Описание остальных параметров смотрите в описаниях одноимённых методов в разделе 4 «Описание интерфейса библиотеки LAUtil.DLL».
Возвращаемое значение:
Описание возвращаемых значений смотрите в описаниях одноимённых методов в разделе 4 «Описание интерфейса библиотеки LAUtil.DLL».
Описание:
Подробности смотрите в разделе 4 «Описание интерфейса библиотеки LAUtil.DLL».
Пример:
-
6. Описание интерфейса UNIDRIVER4LV.DLL для программирования на C и на LabView.
6.1. Назначение библиотеки Unidriver4LV.dll
UNIDRIVER4LV.DLL – это динамическая библиотека, делающая возможным использование драйверов с интерфейсом "IADCDevice" в программах создаваемых в среде LabView. Исходные тексты этой библиотеки находятся в каталоге “..\Samples\ LabView\UniDriver4LV” (“C:\Program Files\Vt\Samples\LabView\UniDriver4LV)” при использовании путей по умолчанию при инсталляции LASDK). Для лучшего понимания описанных далее функций надо ознакомиться с предыдущими разделами.

6.2. Описание экспортируемых функций
Функции для работы со структурами
Использование:
Задание параметров измерений.
Синтаксис:
int      UniDriverInitDMA(unsigned d,
                          int      nStartOf,
                          int      nIntOf,
                          int      nDMABlockSize,
                          int      nDMAMode,
                          float    fFreqStart,
                          int      nTimerStart,
                          float    fFreqPack,
                          int      nTimerPack,
                          int      nFirstChannel,
                          int      nChannelNumber,
                          int      nGain);

int     UniDriverInitDMA1(unsigned d,
                          int      nStartOf,
                          int      nIntOf,
                          int      nDMABlockSize,
                          int      nDMAMode,
                          float    fFreq,
                          int      nTimer0Delay,
                          int      nTimer0Mode,
                          int      nTimer1Delay,
                          int      nTimer1Mode,
                          int      nTimer2Delay,
                          int      nTimer2Mode,
                          int      nFirstChannel,
                          int      nChannelNumber,
                          int      nGain);

int    UniDriverInitTIMER(unsigned d, 
                          int      nTimer,
                          int      nTimerDelay,
                          int      nTimerMode);

int    UniDriverInitDMAEX(unsigned d, 
                          int      nGains[32],
                          int      nChannels[32],
                          int      nControl,
                          int      nSyncLevel);

int   UniDriverInitMEMORY(unsigned d, 
                          int      nStartOf,                                                   
                          float    fFreq,
                          int      nBufferSize,
                          int      nBeforeHistory,
                          int      nDelta[2],
                          int      nGain[2],
                          int      nControl,
                          int      nSyncLevel);

int   UniDriverInitSINGLE(unsigned d, 
                          int      nIntOf,                                                   
                          int      nFirstChannel,
                          int      nChannelNumber,
                          int      nGain);

int     UniDriverInitSLOW(unsigned d, 
                          int      nStartOf,
                          int      nChannelMask,
                          float    fFreq[3],
                          int      nCalibMode[3],
                          int      nGain[3],
                          int      nChan[3],
                          int      nPowerDown[3],
                          int      nIo[3],
                          int      nUnipolar[3]);

int  UniDriverInitOLDLABP(unsigned d,
                          float m_fQuarz0MHz,
                          float m_fQuarz1MHz,
                          int   m_nMaxMemMB,
                          int   m_nPageSizeKW,
                          int   m_nMaxChannels,
                          char* m_pLowFreqLogicFile,
                          char* m_pQ0HiFreqLogicFile,
                          char* m_pQ1HiFreqLogicFile);

Параметры:
d
Указатель на объект, полученный при помощи функции UniDriverCreate.
Описание остальных параметров смотрите в описаниях одноимённых структур для метода Init в разделе 4 «Описание класса интерфейса».
Возвращаемое значение:
Описание возвращаемых значений смотрите в описаниях одноимённых методов в разделе 4 «Описание класса интерфейса драйвера».
Описание:
Все функции с огромным числом параметров просто создают и заполняют соответствующие структуры данных и вызывают функцию UniDriverInit. Все поля в точности соответствуют полям структур.
Пример:
-

6. Имена драйверов для различных плат
6.1. Драйверы и интерфейсы
При инсталляции поставляемого программного обеспечения происходит регистрация драйверов в системном реестре Windows. При этом в реестр записывается следующая информация о драйвере. Создаётся папка с именем драйвера, в которой создаётся два строковых значения. Первое, “Path”, представляет собой путь к файлу динамической библиотеки на диске и используется для загрузки библиотеки. Второе, “UIName”, содержит названия поддерживаемых драйвером интерфейсов и используется при получении интерфейса. При использовании поставляемых с платой программных средств разработки приложений надо использовать в качестве имени драйвера ниже приведённые обозначения.

6.2. Драйверы, поддерживающие интерфейс «IADCDevice»

Название платы	Название драйвера
ЛА-1.5	"LA1_5"
ЛА-2	"LA2"
ЛА-3	"LA3"
ЛА-2M2(M3)	"LAVP" 1
ЛА-4	"LAVP" 1
ЛА-7	"LAVP" 1
ЛА-8	"LA8"
ЛА-12	"LAVP" 1
ЛА-14	"LAVP" 1
ЛА-20	"LA20"
ЛА-и24МX	"LA_I24_3"
Эмулятор платы	"LAEMUL"
ЛА-н10M4	"LA_N10"
ЛА-н10M4 при использовании синтезатора 2 	"LA_N10s"
ЛА-н10M6	"LA_N106", "LA_N106x" (для плат ревизии 2.1)
ЛА-н10M6 при использовании синтезатора 2	"LA_N106s", "LA_N106sx" (для плат ревизии 2.1)
ЛА-н24	"LA_N24"
ЛА-н25	"LA_N25"
ЛА-н05	"LA_N05"
ЛА-н10M6PCI	"LAN10PCI"
ЛА-н10M6PCI при использовании синтезатора 2	"LAN10PCIs"
ЛА-н20PCI	"LAN20PCI"
ЛА-2М3PCI	“LA2M3PCI”
ЛА-1.5PCI	“LA1_5PCI”

1 – универсальный драйвер с автоматическим определением типа платы;
2 – синтезатор частоты служит для плавного задания частота дискретизации (без его использования имеется возможность выбора частоты дискретизации из таблицы фиксированных значений).

